# بررسی یکی از روش‌های خودکار برای تولید مورد آزمون‌ها
# سپهر بیات
# مقدمه
مورد آزمون‌ها (test cases) در مهندسی نرم‌افزار به مجموعه‌ای از اقداماتی گفته می‌شود که بر روی یک سیستم انجام می‌شود تا مشخص شود که آیا نیازمندی‌های نرم‌افزار و عملکرد صحیح آن را براورده می‌کند یا خیر. هدف از یک موردآزمون این است که مشخص کند آیا ویژگی‌های مختلف در یک سیستم مطابق انتظار عمل می‌کنند یا خیر و آیا سیستم تمام استانداردها، دستورالعمل‌ها و نیازمندی‌های مشتری را براورده می‌کند یا خیر.
مورد آزمون‌ها معمولا توسط اعضا تیم تضمین کیفیت (Quality Assurance) یا تیم تست انجام می‌شود و می‌تواند به عنوان دستورالعمل‌های گام به گام برای هر سیستم تست (system test) استفاده شود. تست هنگامی که تیم توسعه یک یا مجموعه‌ای از ویژگی‌های سیستم را توسعه داده و به پایان می‌رساند، آغاز می‌شود. به توالی یا مجموعه‌ای از موردآزمون‌ها، مجموعه آزمون (test suite) گفته می‌شود.
موردآزمون‎‌ها می‌توانند به صورت دستی (manual) یا خودکار (automated) نوشته شوند. موردآزمون‌های دستی همان‌طور که از نامشان پیداست توسط یک انسان اجرا می‌شود و در نقطه مقابل موردآزمون‌های خودکار با کمک ابزارها، اسکریپت‌ها و نرم‌افزار‌هایی اجرا می‌شود. در این مقاله یکی از روش‌های تولید موردآزمون‌های خودکار به نام روش Fuzz Testing را مورد بررسی قرار می‌دهیم.
# Fuzz Testing چیست؟
در توسعه نرم‌افزار و برنامه‌نویسی، فازی (Fuzzy) یا تست فاز (Fuzz Testing)  یکی از تکنیک‌های تست نرم‌افزار خودکار است که شامل ارائه داده‌های نامعتبر، غیر منتظره یا تصادفی به عنوان ورودی برای یک برنامه کامپیوتری است. سپس برنامه برای مواردی مانند خرابی‌ها، شکست کد در ارائه اهداف خود و نشت حافظه مورد نظارت و بازبینی قرار می‌گیرد.
fuzzer برنامه‌ای است که به طور خودکار داده‌های تصادفی یا نیمه تصادفی را به یک سیستم تزریق می‌کند و باگ‌ها را شناسایی می‌کند. بخش تولید داده از مولدها ساخته شده است و شناسایی آسیب پذیری ها بر ابزارهای دیباگ متکی است.
# تاریخچه
اصطلاح "فاز" از پروژه‌ای که در کلاس سیستم‌های عامل پیشرفته که توسط پروفسور بارتون میلر در دانشگاه ویسکانسین تدریس می‌شد، نشات می‌گیرد که نتایج آن متعاقبا در سال 1990 منتشر شد. این پروژه برای آزمایش قابلیت اطمینان برنامه‌های خط فرمان یونیکس (UNIX) با اجرای تعداد زیادی ورودی تصادفی به صورت متوالی تا زمانی که از کار بیفتند طراحی شده است. تیم میلر توانست 25 تا 33 درصد از ابزارهای مورد آزمایش خود را خراب (crash) کند. سپس هر یک از خرابی‌ها را برای تعیین علت اشکال‌زدایی کردند و هر خرابی شناسایی شده را دسته‌بندی کردند. برای اینکه محققان دیگر بتوانند آزمایش‌های مشابهی را با نرم‌افزارهای دیگر انجام دهند، کد منبع (source code) ابزارها، رویه انجام تست و داده‌های خام نتایج به‌دست آمده را در دسترس عموم قرار دادند. این روش اولیه فازی شدن را امروزه به نام جعبه سیاه (black box) شناخته می‌شود.
پروژه اصلی فازی در سال‌های 1995، 2000، 2006 و 2020 پیشرفت‌هایی را داشته:
•	1995: انتشار مقاله بازبینی مجدد فازی که شامل چهار بخش بود:
1.	مطالعه و تحقیق راجع به خط فرمان اصلی یونیکس شامل طیف گسترده‌تری از سیستم‌های یونیکس. این اولین مطالعه‌ای بود که شامل ابزارهای متن‌باز (open source) گنو و لینوکس بود که به‌طور جالبی قابل اعتمادتر از سیستم‌های تجاری یونیکس بودند.
2.	معرفی تست فازی برنامه‌های کاربردی GUI تحت X-Windows. در این مطالعه از هر دو نوع داده‌های ورودی ساختاریافته و بدون ساختار (رویدادهای معتبر ماوس و کیبورد) استفاده شد.
3.	معرفی تست فازی خدمات شبکه‌ای بر اساس ورودی‌های ساختاریافته (structural inputs).
4.	معرفی آزمایش تصادفی مقادیر بازگشتی فراخوانی کتابخانه سیستم که به ویژه به طور تصادفی صفر را از خانواده توابع malloc برمی‌گرداند. تقریباً نیمی از برنامه‌های استاندارد یونیکس نتوانستند چنین مقادیر بازگشتی را به درستی بررسی کنند.
•	2000: اعمال تست فازی برای سیستم عامل ویندوز NT که اخیراً منتشر شده و آزمایش برنامه‌هایی که تحت سیستم پنجره Win32 اجرا می‌شدند. مجدداً، برنامه‌ها با ورودی‌های بدون ساختار و ساختاریافته (رویدادهای صفحه‌کلید و ماوس معتبر) آزمایش می‌‎شدند و تقریباً نیمی از برنامه‌هایی را مورد آزمایش قرار گرفتند از کار افتادند. اعضای تیم علل شکست را شناسایی کردند و آنها را مشابه مطالعات قبلی یافتند.
•	2006: اعمال تست فازی در MacOS X، هم برای برنامه‌های خط فرمان و هم برای برنامه‌های مبتنی بر پنجره. اعضای تیم 135 برنامه کاربردی خط فرمان را آزمایش کردند که 7 درصد از برنامه‌های آزمایش شده را خراب (crash) کردند. علاوه بر این، آنها 30 برنامه کاربردی را که تحت سیستم پنجره MacOS Aqua اجرا می‌شدند، آزمایش کردند و 73 درصد از برنامه‌های آزمایش شده را از کار انداختند.
•	2020: اعضای تیم پرفسور میلر آزمایش‌های کلاسیک، جعبه سیاه و بدون ساختار را روی سیستم‌های یونیکس فعلی، به‌ویژه لینوکس، FreeBSD و MacOS اعمال کردند تا ببینند آیا تکنیک‌های اولیه فازی هنوز کاربردی هستند و آیا برنامه‌های فعلی در برابر این نوع آزمایش‌ها مقاوم هستند یا خیر. آنها تقریباً 75 برنامه کاربردی را روی هر پلتفرم آزمایش کردند، با نرخ شکست 12٪ در لینوکس، 16٪ در MacOS و 19٪ در FreeBSD. (توجه داشته باشید که این نرخ‌های خرابی بدتر از نتایج آزمایش‌های قبلی همان سیستم‌ها بود.) وقتی هر خرابی را تجزیه و تحلیل کردند و آنها را دسته‌بندی کردند، دریافتند که دسته‌بندی کلاسیک خرابی‌ها، مانند خطاهای نشانگر و آرایه و بررسی نکردن کدهای بازگشتی، هنوز به طور گسترده در نتایج جدید حضور داشتند.

در آوریل 2012، گوگل ClusterFuzz را معرفی کرد، یک زیرساخت فازی مبتنی بر فضای ابری برای اجزای امنیتی حیاتی مرورگر وب Chromium. محققان امنیتی می‌توانند Fuzzer های آپلود کرده و اگر ClusterFuzz با کمک این فازرها بتواند باگ‌هایی را پیدا کند، کسی که آن فازر را آپلود کرده پاداش (bug bounty) خود را دریافت می‌کند.
در سپتامبر 2014، Shellshock به عنوان خانواده‌ای از اشکالات امنیتی در UNIX Bash که به طور گسترده مورد استفاده قرار می‌گرفت، کشف شد. بیشتر آسیب پذیری‌های Shellshock با استفاده از fuzzer AFL پیدا شد. (بسیاری از سرویس‌های اینترنت، مانند برخی از وب سرورها، از Bash برای پردازش درخواست‌های خاص استفاده می‌کنند و به مهاجم اجازه می‌دهد تا نسخه‌های آسیب‌پذیر Bash را وادار به اجرای دستورات دلخواه کند. این می‌تواند به مهاجم اجازه دسترسی غیرمجاز به یک سیستم رایانه ای را بدهد.)
در سپتامبر 2016، مایکروسافت پروژه Springfield را معرفی کرد، یک سرویس تست فازی مبتنی بر فضای ابری برای یافتن باگ‌های مهم امنیتی در نرم‌افزار.
در سپتامبر 2020، مایکروسافت OneFuzz را منتشر کرد، یک پلتفرم fuzzing-as-a-service که تشخیص اشکالات نرم افزاری را خودکار می‌کند. این پلتفرم از ویندوز و لینوکس پشتیبانی می‌کند.
# تست‌های تصادفی اولیه
آزمایش برنامه‌ها با ورودی‌های تصادفی به دهه 1950 باز می‌گردد، زمانی که داده‌ها هنوز روی کارت‌های پانچ شده (punched cards) ذخیره می‌شدند. برنامه‌نویسان از کارت‌های پانچ شده که از دسته کارت‌های اعداد تصادفی بیرون کشیده شده‌اند به عنوان ورودی برنامه‌های کامپیوتری استفاده می کردند. اگر یک خروجی نامطلوب نشان داده می‌شد، یک باگ شناسایی شده بود.
به اجرای ورودی‌های تصادفی را تست تصادفی (random testing) یا تست میمون (monkey testing) نیز می‌گویند.
در سال 1981، دو محقق به نام‌های جو دوران (Joe Duran) و سایمون نتافوس (Simeon Ntafos) به‌طور رسمی اثربخشی آزمایش یک برنامه با ورودی‌های تصادفی را بررسی کردند. در حالی که آزمایش تصادفی به طور گسترده به عنوان بدترین وسیله آزمایش یک برنامه تلقی می‌شد، آنها توانستند نشان دهند که این روش یک جایگزین مقرون به صرفه برای تکنیک‌های تست سیستماتیک‌تر است.
در سال 1983، استیو کپس (Steve Capps) در شرکت اپل "The Monkey" را توسعه داد، ابزاری که ورودی‌های تصادفی را برای برنامه‌های کلاسیک سیستم عامل مک، مانند MacPaint تولید می‌کرد. میمون مجازی به قضیه بی‌نهایت میمون اشاره دارد که بیان می‌کند ضربه زدن تصادفی یک میمون به کلیدهای صفحه کلید ماشین تحریر برای مدت زمان بی‌نهایت، در نهایت کل آثار شکسپیر را تایپ می‌کند. در صورت آزمایش، میمون توالی خاصی از ورودی‌ها را می‌نویسد که باعث خرابی (crash) می‌شود.
در سال 1991، ابزار Crashme منتشر شد که قرار بود استحکام سیستم‌عامل‌های یونیکس و شبه یونیکس را با اجرای تصادفی فراخوانی‌های سیستمی با پارامترهای انتخابی تصادفی آزمایش کند.
# انواع فازرها
فازرها را می‌توان به چند روش دسته بندی کرد:
1.	یک فازر می‌تواند مبتنی بر تولید (generation-based) یا مبتنی بر جهش (mutation-based) باشد بسته به اینکه ورودی‌ها از ابتدا تولید به صورت جداگانه تولید شوند یا از تغییر ورودی‌های موجود تولید شوند.
2.	یک فازر می‌تواند نادان (بدون ساختار) یا هوشمند (با ساختار) باشد بسته به اینکه از ساختار ورودی‌ها آگاه باشد یا خیر.
3.	یک فازر می‌تواند بسته به اینکه از ساختار برنامه (program structure) آگاه باشد یا خیر می‌تواند جعبه سفید (white-box)، جعبه خاکستری (grey-box) یا جعبه سیاه (black-box) باشد.
## فازر مبتنی بر تولید و فازر مبتنی بر جهش
یک فازر مبتنی بر جهش از مجموعه موجود دانه‌های ورودی در طول تست فازی استفاده می‌کند. در واقع این دسته از فازرها ورودی‌هایی را با تغییر و جهش ورودی‌های موجود تولید می‌کنند. به عنوان مثال، هنگام فازی کردن کتابخانه تصویری libpng، کاربر مجموعه‌ای از فایل‌های تصویری معتبر PNG را به عنوان ورودی ارائه می‌دهد، در حالی که یک fuzzer مبتنی بر جهش این ورودی‌ها را برای تولید انواع نیمه معتبر (semi-valid) هر ورودی تغییر می‌دهد.
یک فازر مبتنی بر تولید، ورودی‌ها را خود از اول تولید می‌کند. بر خلاف فازرهای مبتنی بر جهش، یک فازر مبتنی بر تولید به وجود یا کیفیت مجموعه‌ای از ورودی‌ها بستگی ندارد.
برخی از فازرها این قابلیت را دارند که هر دو را انجام دهند، تولید ورودی از ابتدا و تولید ورودی با جهش ورودی‌های موجود.
## فازرهای نادان و هوشمند
به طور معمول، فازرها در جهت تولید ورودی برای برنامه‌هایی استفاده می‌شوند که ورودی‌های ساختاریافته، مانند یک فایل، دنباله‌ای از رویدادهای صفحه کلید یا ماوس، یا دنباله ای از پیام‌ها را می‌گیرند. این ساختار ورودی معتبری که توسط برنامه پذیرفته و پردازش می‌شود را از ورودی نامعتبر که به سرعت توسط برنامه رد می‌شود متمایز می‌کند. آنچه یک ورودی معتبر را تشکیل می‌دهد ممکن است به صراحت در یک مدل ورودی (input models) مشخص شود. نمونه‌هایی از مدل‌های ورودی عبارتند از گرامرهای رسمی (formal grammars)، فرمت‌های فایل (file formats)، مدل‌های رابط کاربری گرافیکی (GUI-models) و پروتکل‌های شبکه (network protocols). حتی مواردی که معمولاً به‌عنوان ورودی در نظر گرفته نمی‌شوند، می‌توانند فازی شوند، مانند محتویات پایگاه‌های داده، حافظه مشترک یا متغیرهای محیطی.
یک فازر هوشمند از مدل ورودی برای تولید نسبت بیشتری از ورودی‌های معتبر استفاده می‌کند. با این حال، به طور کلی مدل ورودی باید به طور صریح ارائه شود، که انجام آن زمانی که مدل ناشناخته یا بسیار پیچیده است، دشوار است.
یک فازر نادان به مدل ورودی نیاز ندارد و بنابراین می‌تواند برای تست فازی طیف وسیع‌تری از برنامه‌ها استفاده شود. به عنوان مثال، AFL یک فازر مبتنی بر جهش نادان است که با برگرداندن بیت‌های تصادفی، جایگزین کردن بایت‌های تصادفی با مقادیر «جالب»، و با جابجایی یا حذف بلوک‌های داده، یک فایل اولیه را اصلاح می‌کند.
## فازرهای جعبه سفید، جعبه خاکستری و جعبه سیاه
به طور معمول، یک فازر در صورتی موثرتر است که مقدار بیشتری از کد را تحت پوشش خود قرار دهد. منطق این است که اگر یک فازر از عناصر ساختاری خاصی در برنامه استفاده نکند، در این صورت قادر به آشکارسازی اشکالاتی که در این عناصر پنهان هستند نیز نخواهد بود. برخی از عناصر برنامه حیاتی‌تر از بقیه در نظر گرفته می‌شوند. به عنوان مثال، یک اپراتور تقسیم (division operator) ممکن است باعث خطای تقسیم بر صفر (division by zero) شود.
یک فازر جعبه سیاه با برنامه نرم‌افزاری به عنوان یک جعبه سیاه برخورد می‌کند و از ساختار داخلی برنامه بی‌اطلاع است. به عنوان مثال، یک ابزار تست تصادفی که ورودی‌ها را به صورت تصادفی تولید می‌کند، یک جعبه سیاه در نظر گرفته می‌شود. از این رو، یک جعبه سیاه می تواند چندین ورودی را در ثانیه اجرا کند، می‌تواند به راحتی موازی شود، و می تواند به برنامه‌هایی با اندازه دلخواه مقیاس شود. با این حال، فازرهای جعبه سیاه فقط سطح را خراشیده و اشکالات "کم عمق" را آشکار می‌سازنند.
یک فازر جعبه سفید از تجزیه و تحلیل برنامه برای افزایش سیستماتیک پوشش کد یا رسیدن به مکان‌های حیاتی برنامه استفاده می‌کند. به عنوان مثال، SAGE از اجرای نمادین برای کاوش سیستماتیک مسیرهای مختلف در برنامه استفاده می‌کند. فازرهای جعبه سفید می‌تواند در افشای اشکالاتی که در اعماق برنامه پنهان می‌شوند بسیار موثر باشد. با این حال، زمان مورد استفاده برای تجزیه و تحلیل (برنامه یا مشخصات آن) می‌تواند بسیار زیاد باشد. اگر یک فازر جعبه سفید زمان نسبتاً زیادی را صرف کند تا یک ورودی تولید کند، یک فازر جعبه سیاه کارآمدتر خواهد بود.
یک فازر جعبه خاکستری از ابزارهایی دقیق به جای تجزیه و تحلیل برنامه برای جمع آوری اطلاعات در مورد برنامه استفاده می‌کند. این منجر به سربار عملکرد نسبتا معقولی می‌شود، اما مقدار گسترده‌تری از کد را تحت پوشش فازر قرار می‌دهد، که باعث می‌شود فازرهای جعبه خاکستری ابزارهای تشخیص آسیب‌پذیری بسیار کارآمدی باشند.
# موارد استفاده از تکنیک فازی
فازی بیشتر به عنوان یک تکنیک خودکار برای کشف آسیب‌پذیری‌ها در برنامه‌های مهم امنیتی استفاده می‌شود که ممکن است با اهداف مخرب مورد سوء استفاده قرار گیرند. به‌طور کلی‌تر، فازی برای نشان دادن وجود اشکالات به جای عدم وجود آنها استفاده می‌شود. اجرای یک دوره فازی برای چندین هفته بدون یافتن یک اشکال، درستی برنامه را ثابت نمی کند. از این گذشته، برنامه همچنان ممکن است برای ورودی‌ای که هنوز اجرا نشده است، با شکست مواجه شود. اجرای یک برنامه برای همه ورودی‌ها بسیار گران است. اگر هدف اثبات درستی یک برنامه برای همه ورودی‌ها باشد، باید یک مشخصات رسمی وجود داشته باشد و از تکنیک‌های روش‌های رسمی استفاده شود.
## کشف باگ‌ها
به منظور کشف باگ‌ها، یک فازر باید بتواند رفتار مورد انتظار (عادی) برنامه را از غیرمنتظره (باگی) آن تشخیص دهد. با این حال، یک ماشین همیشه نمی‌تواند یک اشکال را از یک ویژگی تشخیص دهد. در تست خودکار نرم‌افزار، به این مشکل اوراکل تست (test oracle problem) نیز می‌گویند.
به طور معمول، یک فازر برای استفاده از یک مقایسه ساده و عینی، بین ورودی‌های خراب (crashing inputs) و سالم (non-crashing inputs) تمایز قائل می‌شود. خرابی‌ها را می‌توان به راحتی شناسایی کرد و ممکن است نشان‌دهنده آسیب پذیری‌های بالقوه باشد. با این حال، عدم وجود خرابی نشان‌دهنده عدم وجود آسیب پذیری نیست.
## اعتبارسنجی گزارش‌های تحلیل ایستا
تحلیل ایستا، یک برنامه را بدون اجرای واقعی آن تحلیل می‌کند. این ممکن است به نتایج مثبت غیرواقعی‌ای منجر شود که در آن ابزاری مشکلات برنامه را گزارش می‌کند که در واقع وجود ندارند. تکنیک فازی در ترکیب با تجزیه و تحلیل برنامه پویا می‌تواند برای تولید یک ورودی که در واقع شاهد مشکل گزارش شده باشد استفاده شود.
## امنیت مرورگرهای وب
مرورگرهای وب مدرن تحت آزمایش‌های فازی گسترده‌ای قرار دارند. کد Chromium Google Chrome به طور مداوم توسط تیم امنیتی Chrome با 15000 هسته مورد آزمایش فازی قرار می‌گیرد. برای مایکروسافت اج و اینترنت اکسپلورر، مایکروسافت آزمایش فازی را با 670 سال ماشینی در طول توسعه محصولات خود انجام داد.
# منابع
https://en.wikipedia.org/wiki/Fuzzing#cite_note-ossfuzz-20

https://www.apica.io/difference-between-automated-manual-testing/#:~:text=In%20manual%20testing%20(as%20the,tools%2C%20scripts%2C%20and%20software.

https://owasp.org/www-community/Fuzzing#:~:text=A%20fuzzer%20is%20a%20program,identification%20relies%20on%20debugging%20tools.

https://www.synopsys.com/glossary/what-is-fuzz-testing.html#:~:text=Definition,as%20crashes%20or%20information%20leakage.
