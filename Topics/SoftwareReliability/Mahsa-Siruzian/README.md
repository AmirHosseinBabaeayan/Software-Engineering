# <div dir="rtl">تمرین دوم فردی درس مهندسی نرم افزار</div>

# <div dir="rtl">موضوع</div>
<div dir="rtl">مدل های رایج قابلیت اطمینان نرم افزار</div>

# <div dir="rtl">گردآورنده</div>
<div dir="rtl">مهسا سیروزیان فرد</div>

# <div dir="rtl"> استاد درس</div>
<div dir="rtl">دکتر حسن بشیری</div>

# <div dir="rtl">دستیار استاد</div>
<div dir="rtl">آقای بابائیان</div>

# <div dir="rtl">مقدمه</div>
<div dir="rtl">
قابلیت اطمینان نرم افزار  احتمال عملکرد بدون خرابی یک نرم افزار را برای یک دوره مشخص، در یک محیط مشخص را بیان می کند.  قابلیت اطمینان یک دیدگاه مشتری مدار از کیفیت نرم افزار است.
</div><div dir="rtl">
با توجه به کاربردهای گسترده سیستم های نرم افزاری در همه جوانب زندگی امروزی، اهمیت تولید نرم افزارهای تقریباً بدون خطا و با کیفیت بالا بیش از پیش پیدا شده است. قابلیت اطمینان نرم افزار یک رهیافت مهم برای ارزیابی کیفیت نرم افزار در نظر گرفته شده است. روشها و مدلهای متنوع و متعددی در این زمینه مطرح شده است که به دلایل متعددی بسیاری از این موارد کمتر شناخته شده اند.
</div>

# **<div dir="rtl">مدل قابلیت اطمینان نرم افزار چیست؟**</div>

<div dir="rtl">
مدل های قابلیت اطمینان نرم افزار در هنگام فرایند دیباگ کردن نرم افزار استفاده می شوند و بطور کلی برای اندازه گیری کیفیت نرم افزار مورد استفاده قرار میگیرند. در این مدل ها، نرم افزار برای یک دوره و بازه زمانی مشخص تست می شود که در طی آن ممکن است خرابی و اشکال رخ دهد.
</div>
<div dir="rtl">
این خرابی ها باعث ایجاد تغییرات در طراحی میشود و ورژن جدید طبق آنها ایجاد و دوباره تست میشود. این چرخه بارها وبارها تکرار میشود تا تمام نیاز های ما از نرم افزار براورده شوند.
</div>
<div dir="rtl">
همچنین یک مدل بررسی قابلیت اطمینان نرم افزار، فرمی از یک فرایند تصادفی است که رفتار شکست های نرم افزار در مدت زمان را نشان میدهد.
</div>

<div dir="rtl">
با تلاش انسانها برای فهمیدن اینکه چرا و چگونه یک نرم افزار دچار مشکل می شود و تلاش برای فهمیدن قابلیت اطمینان بصورت کمی و عددی، مفهوم قابلیت اطمینان نرم افزار پدید آمد. در حال حاضر بیش از 200 مدل برای این مفهوم ایجاد شده اما بخش زیادی از این مسئله که چگونه قابلیت اطمینان را به یک عدد تبدیل کرد هنوز حل نشده.
</div>
<div dir="rtl">
نکته قابل توجه این است که نمی توان یک مدل را برای تمامی نرم افزار ها استفاده کرد و آنرا تعمیم داد، هیچ مدلی صد در صد کامل نیست.
</div>

#  <div dir="rtl">**مدل های رایج برای قابلیت اطمینان نرم افزار**</div>
<div dir="rtl">
شکل زیر سلسله مراتب مدل های قابلیت اطمینان نرم افزار را نشان می دهد. در ابتدا این مدل ها به دو دسته کلی قطعی و احتمالی تقسیم می شوند.
</div>

![enter image description here](https://s6.uupload.ir/files/pic1_ht66.png)

<div dir="rtl">
دو مدل رایج در دسته بندی قطعی، Halstead’s software metric و McCabe’s cyclomatic هستند.
</div>
<div dir="rtl">
مدل های دسته احتمالی نیز شامل موارد زیر است:
</div>
<div dir="rtl">
 - مدل نرخ خطا(Failure Rate Model)
 </div> <div dir="rtl">
 -  مدل شمارش شکست یا خطا (Failure or Fault Count) که مدل های NHPP را شامل میشود
  </div> <div dir="rtl">
 - مدل Error or Fault Seeding
  </div> <div dir="rtl">
 - مدل رشد قابلیت اطمینان (Reliability Growth Model
 </div>
  <div dir="rtl">
که چند مدل  رایج از هرکدام از دسته های بالا را بررسی میکنیم.
 </div> 

## **<div dir="rtl">مدل های نرخ خطا</div>**

### **<div dir="rtl">1- مدل  Jelinski-Moranda(JM)</div>**
<div dir="rtl">
به عنوان مدل فرایند مارکوف نیز شناخته میشود و جزو پر استفاده ترین مدل ها برای تخمین قابلیت اطمینان نرم افزار می باشد که بسیاری از مدل های بعد از خودش را که در اصل از این مدل ساده، ایده گرفته اند را تحت تاثیر خیلی زیادی قرار داده.
 </div> 
 
#### **<div dir="rtl">  ویژگی های مدل JM </div>**
 <div dir="rtl">
1. یک مدل از نوع جبری و ریاضی است
 </div> <div dir="rtl">
2. یکی از مدل های پیشگام و یکی از مشهورترین مدل های جعبه سیاه به حساب می آید
</div> <div dir="rtl">
3.این مدل همواره یک پیش بینی قابلیت اطمینان بیش از حد خوشبینانه را ارائه میدهد
</div> <div dir="rtl">
4.این مدل یک مرحله دیباگ کردن بی نقص را دنبال می کند، به عنوان مثال یک خرابی شناسایی شده را با یک مدل ساده از بین می برد.
</div> <div dir="rtl">
5.نرخ خرابی این مدل در بازه شکست i ام، بصورت زیر بدست می آید: 
</div>

**λ(ti) = ϕ [N-(i-1)], i=1, 2... N .........equation 1**
<div dir="rtl">
که معنای نماد ها بصورت خلاصه به شرح زیر می باشد:
</div>

|  مفهوم  | نماد |
|--|--|
|  عددی ثابت که نشانگر یک تناسب بین میزان شکست بوجود آمده<div dir="rtl"> توسط هر خطا را نشان می دهد | ϕ |
| <div dir="rtl"> تعداد ارور های اولیه در نرم افزار | N |
| <div dir="rtl"> فاصله زمانی بین ارور i-1 ام تا iام | ti |

<div dir="rtl">
 مقدار میانگین و تابع شدت خطا برای این مدل که توابعی دو جمله ای هستند، می تواند از حاصل ضرب تعداد خطاهای inherent در توابع شکست تجمعی بدست بیاید:
</div>

![enter image description here](https://s6.uupload.ir/files/1_6kxc.png)
<div dir="rtl">
معنی هر نماد در این مدل، در جدول زیر آمده است:
</div>

![enter image description here](https://s6.uupload.ir/files/2_encj.png)

### <div dir="rtl"> فرضیات مدل JM </div>
<div dir="rtl">
 - تعداد خطاهای اولیه نرم افزار نامعلوم است اما عددی ثابت است
</div><div dir="rtl">
 - هر خطا در نرم افزار از دیگری مستقل است و به همان اندازه خودش احتمال
   دارد که در طول آزمایش، شکست ایجاد کند.
</div><div dir="rtl">
 - فواصل زمانی بین وقوع خطاها، بصورت توابع نمایی و متغیرهای تصادفی توزیع میشوند.
</div><div dir="rtl">
 - میزان نرخ خطا در بازه وقوع یک خطا بصورت عددی ثابت باقی می ماند و تغییر نمیکند.
</div><div dir="rtl">
 - میزان نرخ خطا با تعداد شکست هایی که در نرم افزار باقی مانده متناظر است
</div><div dir="rtl">
 - یک ارور شناسایی شده در این مدل بلافاصله پس از شناسایی حذف میشود و در
   طول حذف، هیچ ارور جدیدی شناسایی و معرفی نمیشود
</div><div dir="rtl">
 - هر زمانی که یک خرابی و شکست ظاهر میشود، خطا با قطعیت کاهش می یابد.
</div><div dir="rtl">

#### **<div dir="rtl">  تغییرات در مدلJM </div>**
<div dir="rtl">
همانطور که گفته شد، مدل JM اولین مدل مطرح، بین مدل های قابلیت اطمینان نرم افزار بود. بعدها چند محقق به اصلاح این مدل پرداختند و تغییراتی را به منظور اصلاح، در آن ایجاد کردند و مدل های جدیدتری ارائه شدند. تعدادی از این تغییرات و مدلهای بوجود آمده را در ادامه بررسی میکنیم.
</div>


### **<div dir="rtl">2- مدل Jelinski-Moranda Geometric**</div>
<div dir="rtl">
این مدل با درنظر گرفتن اینکه تابع نرخ شکست در ابتدا یک عدد ثابت مثل D است و بصورت هندسی در زمان کاهش می یابد عمل می کند. نرخ خرابی و روش قابلیت اطمینان در زمان بین خرابی ها در خطای i ام بصورت زیر میباشند:
</div>

![enter image description here](https://s6.uupload.ir/files/3_qry.png)
<div dir="rtl">
که در آن K یک پارامتر از تابع هندسی می باشد که بین 0 تا 1 مقدار دهی میشود.
</div>

### <div dir="rtl">3- مدل Schick Wolverton (S-W)</div>
<div dir="rtl">
این مدل شباهت زیادی به مدل JM دارد، تنها تفاوت در این است که  نرخ خرابی در بازه i ام با گذشت زمان از آخرین فرایند دیباگ کردن وخطایابی افزایش می یابد و دیگر مقدار ثابتی نخواهد بود.
</div><div dir="rtl">
مفروضات این مدل به شرح زیر می باشد:
</div><div dir="rtl">
-خطاها بصورت تصادفی رخ می دهند
</div><div dir="rtl">
-نرخ تشخیص خطاها، در هر بازه زمانی تعریف شده ثابت است.
</div><div dir="rtl">
-خطاها از همدیگر مستقل هستند
</div><div dir="rtl">
-هیچ خطای جدیدی بوجود نمی آید و خطاها ثابت اند.
</div><div dir="rtl">
-اشکالات و خطاها پس از شناسایی شدن، اصلاح و رفع می شوند.
</div><div dir="rtl">
-نرخ تشخیص خطا در آن متناسب با تعداد خرابی و اشکالات موجود است
</div><div dir="rtl">
در این مدل، تابع نرخ خطا بصورت زیر می باشد:
</div>

![enter image description here](https://s6.uupload.ir/files/4_h7z.png)
![enter image description here](https://s6.uupload.ir/files/5_2um.png)


### <div dir="rtl">4- مدل Goel and Okumoto Imperfect Debugging</div>
<div dir="rtl">
بسط داده شده مدل JM است  با فرض اینکه یک ارور، هنگام وقوع احتمال رخداد p را دارد.
</div><div dir="rtl">
در این مدل نرخ شکست و خرابی در شکست i ام با رابطه زیر بدست می آید:
</div>

![enter image description here](https://s6.uupload.ir/files/6_xf75.png)
 <div dir="rtl">
 همانطور که گفته شد p، احتمال وقوع خطا و  λ هم نرخ خطا در هر کدام از شکست ها می باشد.
</div>

### <div dir="rtl">5- مدل Littlewood-Verrall Bayesian</div>
 <div dir="rtl">
این مدل زمان بین خرابی ها را بصورت مقادیر نمایی تصادفی مستقل از هم در نظر می گیرد، همراه با پارامتر € i=1, 2 ....n  که هر یک از آنها نیز یک پارامتر  Ψ(i)  و  α  دارند که نشان دهنده کیفیت برنامه نویسی و مشکل عملکردی در توزیع گاماهای قبلی هستند.
</div>

![enter image description here](https://s6.uupload.ir/files/7_lk2o.png)
 <div dir="rtl">
که در این رابطه B نشان دهنده عامل کاهش خطا می باشد.
</div>


## <div dir="rtl">مدل های شمارش خطا (Failure or Fault Count models)</div>

### <div dir="rtl">1- مدل Musa’s Execution Time</div>

 <div dir="rtl">
این مدل توسط J.D. Musa در سال 1979 ارائه شد و در آن قابلیت اطمینان نرم افزار بر اساس زمان اجرا محاسبه میشود.
</div> <div dir="rtl">
این مدل محبوب ترین و اصلی ترین مدل مورد استفاده در قابلیت اطمینان نرم افزار است. به علل زیر:
</div>
 <div dir="rtl">
-مدلی ساده است و قابلیت فهم بسیار آسانی دارد
</div> <div dir="rtl">
-پارامترهای مطرح شده در آن، به وضوح با دنیای فیزیکی ارتباط دارد
</div> <div dir="rtl">
-میتواند برای پیش بینی دقیق قابلیت اطمینان مورد استفاده قرار گیرد
</div> <div dir="rtl">
مدل زمان اجرای پایه، رفتار خرابی و شکست را ابتدا با استفاده از زمان اجرا تعیین می کند. زمان اجرا ممکن است بعدها به زمان تقویمی نیز تبدیل شود.
</div> <div dir="rtl">
رفتار خرابی و شکست  یک فرایند غیرهمگن و پواسیون است و ویژگی های آن در زمان متفاوت است.
</div>

#### <div dir="rtl"> متغیرهای موجود در این مدل </div> 
<div dir="rtl">
 شدت شکست (λ): تعداد شکست ها در یک واحد زمانی
</div> <div dir="rtl">
زمان اجرا (τ): مدت زمانی که برنامه در حال اجرا است
</div> <div dir="rtl">
میانگین شکست تجربه شده  (μ): میانگین شکست های اتفاق افتاده در یک فاصله زمانی، که از رابطه زیر بدست می آید:
</div> 

![enter image description here](https://s6.uupload.ir/files/8_a92x.png)


<div dir="rtl">
که در آن:
</div> <div dir="rtl">
-λ0  شدت شکست اولیه در زمان شروع اجرا است و -v0 تعداد کل خرابی هایی است که در مدت زمان بینهایت رخ میدهد(تعداد شکست هاست که انتظار داریم در نهایت مشاهده شود)
</div> <div dir="rtl">
و شدت شکست که تابعی از واحد زمان است بصورت زیر تعریف میشود:
</div>

![enter image description here](https://s6.uupload.ir/files/9_jy9j.png)


### <div dir="rtl">2- مدل Goel-Okumoto NHPP</div>
<div dir="rtl">
توسط Goel و Okumoto در سال 1979 توسعه یافت. این مدل یک مدل dynamic می باشد.
</div><div dir="rtl">
فرضیات این مدل به شرح زیر می باشد:
</div>
<div dir="rtl">
- تعداد خطا های رخ داده در زمان t برحسب یک توزیع پواسیون، دارای یک تابع مقدار میانگین μ(t) بدست می آید. این تابع مقدار میانگین یک محدوده الزامی بصورت زیر دارد:
</div>
<div dir="rtl">
- تعداد شکست های نرم افزار در بازه زمانی (t, t+Δt] که Δt → 0 متناسب است با تعداد مورد انتظار از خطاهای شناسایی نشده (N - μ(t)). مقدار ثابت تناسب نیز همان ∅ است.
</div>

![enter image description here](https://s6.uupload.ir/files/10_e0wd.png)


<div dir="rtl">
- برای هر بازه زمانی غیر از بینهایت  t1 < t2 < · · · < tn، تعداد خرابی و شکست رخ داده در هر بازه ناهمگون (0, t1 ),(t1, t2)... (tn-1,tn)، مقادیر مستقل از هم دارند.
</div><div dir="rtl">
- هر زمانی که یک خرابی و شکست ظاهر میشود، خطا با قطعیت حذف می شود، بدون اینکه خطای جدیدی در نرم افزار ایجاد شود.
</div><div dir="rtl">
- حذف اشکالات با مدل NHPP انجام می شود.
</div><div dir="rtl">
- وجود خطاهای باقی مانده در سیستم علت رخ دادن خرابی در نرم افزار است.
</div><div dir="rtl">
- تعداد خطاهای تشخیص داده شده در یک فاصله زمانی با تعداد خطاهای موجود در همان زمان متناسب است.
</div><div dir="rtl">
- تعداد خطاهای موجود بر روی نرخ خرابی اثر می گذارد.
</div><div dir="rtl">
- خطاها از همدیگر مستقل هستند.
</div><div dir="rtl">
- تناسب حذف خرابی ها و رخ دادن خطا مقادیری ثابت هستند.
</div><div dir="rtl">
از آنجایی که هر خطایی که بر اساس یک شکست ایجاد می شود بطور کامل ترمیم و حذف می شود، تعداد خطاها در ابتدای تست نرم افزار با تعداد خطاها پس از بینهایت بار تست کردن آن برابر خواهد بود.
</div><div dir="rtl">
بر اساس فرض دوم مطرح شده، شدت شکست در زمان t از رابطه زیر بدست می آید:
</div>

![enter image description here](https://s6.uupload.ir/files/11_9k4.png)

<div dir="rtl">
درست همانند مدل JM، شدت شکست، از حاصل ضرب نرخ خطای ثابت برای یک خطا در تعداد خطاهای باقی مانده مورد انتظار در نرم افزار بدست می آید.
</div><div dir="rtl">
در این رابطه خود N نیز یک مقدار مورد انتظار است.
</div>

### <div dir="rtl">3- مدل Goel Generalized NHPP</div>

<div dir="rtl">
در طول فرایند تست، نرخ شکست مقدار ثابتی نیست، این مقدار ابتدا افزایش و سپس کاهش می یابد. Goel یک مدل تعمیم یافته از NHPP را برای مدیریت این کاهش و افزایش نرخ شکست ارائه داد. که در آن:
</div>

![enter image description here](https://s6.uupload.ir/files/12_vplr.png)

<div dir="rtl">
a میزان مورد انتظار از تعداد شکست ها، b و c مقادیر ثابتی هستند که کیفیت تست را نشان میدهند. نرخ خطا نیز از رابطه زیر بدست می آید:
</div>

![enter image description here](https://s6.uupload.ir/files/13_71t.png)

### <div dir="rtl"> 4- مدل IBM Binomial and Poisson</div>
<div dir="rtl">
در این مدل نرخ تشخیص خطا به عنوان یک فرایند گسسته در نظر گرفته میشود و یک توزیع دوجمله ای یا پواسیون را دنبال میکند.
</div><div dir="rtl">
فرض در این مدل به این صورت است که سیستم نرم افزاری بصورت تدریجی تست و توسعه داده شده. از این مدل میتوان در تست های هر دو سطح ماژول و سیستم استفاده کرد.
</div>

### <div dir="rtl">5- مدل Shoo Man Exponentioal</div>
<div dir="rtl">
این مدل بسیار مشابه JM model است، تنها تفاوت در این است که نرخ خرابی از معادله زیر بدست می آید:
</div>

![enter image description here](https://s6.uupload.ir/files/14_y62.png)

<div dir="rtl">
که در آن t زمان عملکرد سیستم، I تعداد کل دستورات در برنامه، τ  مدت زمان دیباگ و رفع خطا، nc (τ)  تعداد کل خطاهای رفع شده و k ثابت تناسب است.
</div>


### <div dir="rtl">6- مدل تعمیم یافته پواسون (Generalized Poisson)</div>
<div dir="rtl">
 تابع مقدار میانگین در این مدل بصورت زیر می باشد:
 </div>
 
 ![enter image description here](https://s6.uupload.ir/files/15_392j.png)

![enter image description here](https://s6.uupload.ir/files/16_324y.png)


### <div dir="rtl"> 7- مدل لگاریتمی Musa-Okumoto</div>
<div dir="rtl">
 این مدل یک مدل لگاریتمی است که در آن قابلیت اطمینان نرم افزار بر اساس زمان اجرا محاسبه میشود. شدت شکست و خطا از رابطه زیر بدست می آید:
</div>

![enter image description here](https://s6.uupload.ir/files/17_wa68.png)


## <div dir="rtl"> مدل های Fault seeding</div>

<div dir="rtl">
در این نوع مدل ها، تعداد مشخصی از خطاها در یک برنامه "بذرپاشی" شده. تعداد خطاهای بذرپاشی شده محلی، هنگام انجام فرایند تست شمارش میشوند. با استفاده از مدل های تخمین متفاوت، تعداد خطاهای محلی و قابلیت اطمینان نرم افزار تخمین زده میشود.
</div>

### <div dir="rtl"> 1- مدل Mills Seeding</div>

<div dir="rtl">
یکی از مدل های محبوب و پایه ای در مدل های fault seeding است. برای تست یک برنامه، یک عدد تصادفی از خطاها بذرپاشی می شوند و سپس برنامه برای یک فاصله زمانی خاصی تست می شود. تعداد اصلی خطاهای ذاتی می تواند از روی تعداد خطاهای ذاتی و بذرپاشی شده که در زمان تست لحاظ نمی شوند محاسبه شود.
</div><div dir="rtl">
این مدل ها با عنوان tagging models نیز شناخته میشوند، زیرا یک خطای بذرپاشی شده در برنامه tag میشود.
</div>

### <div dir="rtl">2- مدل Basin</div>
<div dir="rtl">
 مدل basin به عنوان یک روش دو مرحله ای شناخته می شود که هر یک از آنها برای تخمین تعداد خطاهای ذاتی برنامه استفاده می شود.
</div>

### <div dir="rtl">3- مدل Nelson</div>
<div dir="rtl">
فردی به نام نلسون مدلی را پیشنهاد کرد که در آن قابلیت اطمینان نرم افزار با اجرا کردن برنامه با n ورودی اندازه گرفته میشد.
</div><div dir="rtl">
ورودی ها بصورت تصادفی از دامنه ورودی ای که داریم انتخاب می شود. این نمونه برداری تصادفی n ورودی، یا از طریق توزیع احتمال یا از طریق توزیع ورودی کاربر انجام میشود.
</div>

### <div dir="rtl">4- مدل برمبنای دامنه ورودی (Input Domain based)</div>
<div dir="rtl">
در این مدل test case ها از دامنه ورودی ها ایجاد میشوند. تقسیم بندی دامنه ورودی به کلاس های برابر، کار دشواری است.
</div><div dir="rtl">
قابلیت اطمینان با تعداد شکست ها یا تعداد اجراهای تست کیس ها اندازه گیری می شود.
</div>

### <div dir="rtl">3- مدل Lipow</div>
<div dir="rtl">
Lipow مدلی را معرفی کرد که احتمال رخداد خطا را در هر تست نرم افزاری شناسایی می کند. سپس احتمال پیدا کردن تعداد خطاهای ذاتی یا بذرپاشی شده را برای تست های مستقل از هم را حساب میکند.
</div>

# **<div dir="rtl">لینک ویدئو</div>**
[https://www.aparat.com/v/ngOs2](https://www.aparat.com/v/ngOs2)


# **<div dir="rtl">منابع**</div>

[https://www.slideshare.net/amirbabol/software-reliability-model-56428916](https://www.slideshare.net/amirbabol/software-reliability-model-56428916)

[https://www.javatpoint.com/software-engineering-basic-execution-time-model](https://www.javatpoint.com/software-engineering-basic-execution-time-model)

[https://modelling.semnan.ac.ir/article_2569_d1c0fa02272942c43cc2ff4b681d0fb1.pdf](https://modelling.semnan.ac.ir/article_2569_d1c0fa02272942c43cc2ff4b681d0fb1.pdf)

[https://sciresol.s3.us-east-2.amazonaws.com/IJST/Articles/2015/Issue-29/Article26.pdf](https://sciresol.s3.us-east-2.amazonaws.com/IJST/Articles/2015/Issue-29/Article26.pdf)
