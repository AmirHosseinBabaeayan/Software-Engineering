 ### &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;  به نام خدا 

 ### &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 
  روش‌های رسمی برای تولید نرم افزار 
### &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;
(تمرین دوم فردی مهندسی نرم افزار)
 ### &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 
 &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;
درس: مهندسی نرم افزار
 ### &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 
 &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;
 استاد: دکتر حسن بشیری
  ### &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 
 &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;
 دستیار استاد: آقای بابائیان
  ### &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; 
 دانشجو: شفیع شاکری 9704913
  ### &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; 
##
مقدمه
###
تولید نرم افزار با توجه به روش‌های رسمی، شامل مجموعه‌ای از فعالیت‌ها است که سعی دارد پروژه‌ی نرم‌افزاری را در قالب روابطی رسمی و ریاضی، سیستم‌های کامپیوتری را تعریف، توسعه، پیاده‌سازی و ارزیابی نماید. در این مدل، با استفاده از تحلیل‌های ریاضی، بسیاری از ابهامات، نواقص و عدم سازگاری نرم‌افزار را تا زمان اجرا غیرقابل تشخیص هستند را تا حد زیادی می‌توان به سادگی کشف و تصحیح نمود. 
ملاحظات مربوط به قابلیت اجرای این مدل در محیط های تجاری شامل موارد زیر می شود:

•	توسعه مدل های رسمی در حال حاضر بسیار وقت گیر و پرهزینه است.

•	از آنجا که تعداد معدودی از نرم افزار سازان دارای زمینه لازم برای اجرای روش های رسمی هستند، آموزش گسترده ای مورد نیاز است.

•	استفاده از مدل ها به عنوان راهکار ارتباطی با مشتریانی که دید فنی ندارند، دشوار است.

نظر به این ملاحظات، روش های رسمی احتمالا در میان نرم افزار نویسانی هوادار پیدا می کند که باید نرم افزارهای ایمنی-حیاتی (safety-critical) (مثلا نرم افزارهای دستگاههای پزشکی و هوافضا) بسازند یا در میان آنهایی که در صورت بروز خطا در نرم افزار دستخوش زیان های اقتصادی کلان می شوند.

بنابراین مزایا و معایب روش‌های رسمی برای تولید نرم افزار به صورت زیر است:

##
مزایا
-	بدیع 
-	سازگار
-	بدون ابهام
-	کاربرد در سیستم‌های حساس
##
معایب
-	وقت گیر و پر هزینه
-	کاربر محدود
-	نیاز به آموزش جامع 
-	مشکل ارتباط با مشتری

###
حال با توجه اینکه تعداد روش‌های رسمی برای تولید نرم افزار زیاد است، انتخاب یک روش رسمی مناسب از میان روش‌های رسمی موجود بسیار حائز اهمیت است.

###
![image](https://user-images.githubusercontent.com/106925008/172068103-62fea4f5-e62c-4682-a20d-a31010170a09.png)
###
![image](https://user-images.githubusercontent.com/106925008/172068114-12b4c600-2df0-4e2b-bdf1-d17177630d1c.png)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
نمودار زمینه برای سنجش روش‌های رسمی

##
###
روش‌های رسمی 

به طور کلی روش‌های رسمی بر اساس چگونگی نحوه توصیف یک نرم افزار به چهار گروه اصلی تقسیم می‌شوند:

الف) مبتنی بر حالت(State-Based):

یک حالت بیانگر وضعیت سیستم در نقطه یا بازه‌ای از زمان است. در این دسته از روش‌ها تمرکز بر روی حالت‌های سیستم بوده و توصیف اعمال سیستم (توابع) با تمرکز بر این که پس از اجرای این اعمال، چه تغییر حالت‌هایی در سیستم رخ می دهد، صورت می گیرد. در شکل 2 توصیف یک فلیپ فلاپ که دارای دو حالت صفر و یک می باشد با استفاده از ماشین حالت متناهی ارائه شده است. 
توصیف رسمی شکل 2 با (1) بیان شده است:


![image](https://user-images.githubusercontent.com/106925008/172068311-2728ab86-8182-4bb8-b816-d6c1c64878fb.png)

در گزاره اول (1) ماشین حالت متناهی را به صورت یک چندتایی (∑, S, S0, E, F) معرفی نموده که در آن ∑ الفبای ورودی، S مجموعه ای از حالت های ماشین، S0 حالت آغازین، E مجموعه ای از لبه ها (E زیرمجموعه ای از SxSxS∑ است) و F مجموعه ای از حالتهایی است که توسط ماشین پذیرفته می شوند. 


###
ب) مبتنی بر رخداد:

یک رخداد پیامی است که بین محیط و سیستم مبادله می شود و در این دسته از روشها تمرکز بر توصیف وقوع رخدادها و ترتیب وقوع آنها می باشد. توصیف رسمی رخداد به صورت (2) در شبکه پتری است. در این رابطه  Miبیانگر حالت iام و نشانه های موجود در مکان ها در آن حالت بوده که با وقوع گذار t سیستم وارد حالت Mj می گردد.
به طور مثال برای توصیف یک پشته با استفاده از شبکه های پتری تمرکز ما بر بیان وقوع رخدادهایی مانند درج کردن و حذف کردن از پشته می باشد که ترتیب وقوع رخدادهای ذکر شده با استفاده از نشانه ها و گذارها در این روش مشخص می گردد 


![image](https://user-images.githubusercontent.com/106925008/172068407-a7ae7670-c91b-4c90-a4da-eb6490041c9d.png)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;تعريف پيمانه اي كتاب تاريخ تولد درZ 
 
 ###
 
 ج) منطقی:
 
این دسته از روشها از قوانین و نمادهای منطقی )منطق رتبه اول با بالاتر( جهت توصیف و مدل سازی سیستم بهره می برند. منطق گزاره‌ای یک شاخه از منطق بوده که در آن از گزاره‌ها و از علایم ربط منطقی برای ارتباط برقرار کردن بین گزاره ها استفاده میشود [1]. در این منطق هر گزاره می تواند دارای مقدار صحیح یا غلط باشد. به طور مثال اگر هوا ابری باشد آنگاه باران میبارد. حساب شرطی با منطق شرطی، بسط یافته منطق گزاره ای بوده که در آن نمادهای گزاره، زیرموضوع و کمیت سنج‌ها از هم جدا شده اند. به طور مثال در منطق گزارهای می توان نماد P را به گزاره "All men are mortal" اختصاص داد اما در منطق شرطی می توان گزاره (x)M را تعریف نمود که جایگزین مردن برای زیرموضوع بر خواهد بود. د را می توان به کمیتاسنج جهانی مقید نمود (For all) و جمله منطقی را در نهایت به صورت (All x.M (x بیان کرد. تعداد زیرموضوع ها در منطق شرطی رتبه اول یکی بوده و در واقع تک متغیره می باشد اما در منطق‌های شرطی رتبه بالاتر تعداد زیرموضوع‌ها و متغیرها می تواند بیشتر از یکی باشند. 


د) جبری:

در این گونه از روش های رسمی، سیستم به وسیله قوانین جبری یعنی مجموعه ها و عملیات روی مجموعه ها مدل شده و رفتار رخدادها (توابع) با استفاده از معادلات توصیف می گردند. هر توصیف جیری شامل دو بخش است: (۱) قسمتی برای توصیف داده (با استفاده از مجموعه ها) و عملیات بر روی آن و (۲) بخش توصیف عملیات با استفاده از بدیهیات. به طور مثال برای توصیف اعداد طبیعی
N با معرفی صفر و با دو عمل تعیین عضو بعدی و جمع به صورت (3) و (4) نشان داده میشوند؛ روابط (3) و (4) به ترتیب نشان دهنده عملگرها (توابع) و اصول هستند.
###

![image](https://user-images.githubusercontent.com/106925008/172068471-765dac68-6096-409c-ba68-45d9b6da70c9.png)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
شکل 3


###


![image](https://user-images.githubusercontent.com/106925008/172068503-3d9da86a-3b54-40d1-b241-ea781bd6ff44.png)

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  شکل 4


###


در این بخش از گروه‌های مختلف نام برده شده، نمونه ای انتخاب و سپس به ارزیابی آن روش رسمی بر اساس معیارهای ارائه شده در بخش قبل پرداخته شده است. از گروه اول به روش Z، از گروه دوم به Event-B، از گروه سوم به منطق زمانی بی درنگ و از گروه چهارم به CSP می پردازیم. 


روش مبتنی بر حالت، زبان Z


ایده Z برای اولین بار در سال ۱۹۷۷ به وسیله Abrial که عضو گروه تحقیقاتی برنامه نویسی دانشگاه آکسفورد بود، ارائه گردید. این زبان یک زبان رسمی توصیفی بر پایه تئوری مجموعه ها و منطق شرطی رتبه اول می باشد.
نوع داده: این روش موجودیتهای سیستم را با نوع داده تعریف می نماید که انواع داده پیش تعریف برای این روش شامل نوع داده صحیح و نوع داده طبیعی می باشد. به طور مثال برای توصیف جهت حرکت آسانسور (دو حالت بالا و پایین) و برای دکمه آسانسور (دو حالت خاموش و روشن) دو نوع داده تعریف می کنیم (روابط (5) و (6)). جهت حرکت آسانسور (رابطه (6) و دکمه آن رابطه (5)) از جنس
داده های شمارشی است. رابطه (7) که قید روی مقادیر داده ها را نشان می دهد، اظهار می دارد که شماره طبقات باید از نوع عدد صحیح و مقدار بزرگ تر از صفر باشد.



###
![image](https://user-images.githubusercontent.com/106925008/172068673-40b8455d-b379-4aef-bc64-0490f70cfbdd.png)


فضای حالت:
مجموعه متغیرهای دارای نوع که در توصیف سیستم استفاده می شوند، فضای حالت سیستم را مشخص می سازند.


 پیمانه:
 تعریف حالتها و چگونگی تغییر آنها به وسیله عملیات، توسط ساختارهایی به نام شما (شکل 3) توصیف می شوند. روش Z دارای امکان توصیف پیمانه ها با استفاده از شما است. به طور مثال در شکل 3 در بخش ابتدایی توصیف یک کتاب جهت ثبت تاریخ تولد و اسامی افراد معرفی شده و در قسمت بعدی با استفاده از نماد ∆ به این بخش ارجاع شده است. 
 
 
وراثت:
روشZ دارای نماد نحوی جهت پشتیبانی از مفاهیم وراثت و شیءگرایی نبوده اما Object – Z که نسخه بسط یافته زبان Z است، از مفاهیم شیء گرایی پشتیبانی می نماید.


زمان:

در روش Z فقط به تقدم و تأخر رخدادها (توصیف حالت فعلی و بیان یک کنش جهت رفتن حالت بعدی) توجه شده و فاصله زمانی رخدادها مورد توجه قرار نمی گیرد. 


اثبات پذیری:
با توجه به استفاده از نمادهای ریاضی در توصیف های اين روش امكان اثبات توصيف‌ها براي اين روش وجود دارد. به طور مثال شکل 3 با مجموعه 8 اثبات می‌شود.




![image](https://user-images.githubusercontent.com/106925008/172068782-5cfd7467-e7fc-4043-9c32-fad70e4b3dd6.png)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; شکل 8



پشتیبانی ابزاری:

ابزارهای مختلفی برای روش Z طراحی شده که بسیاری از آنها در حد پروژه های دانشجویی بوده و تعداد اندکی از آنها دارای کیفیتی در حد یک محصول و ارائه دهنده یک محیط مجتمع مناسب جهت استفاده توسعه دهندگان سیستم ها می باشد. پروژه CZT  که توسط Andrew Martin در آزمایشگاه کامپیوتر دانشگاه آکسفورد پایه گذاری شده شامل مجموعه ابزار جهت ویرایش، بررسی نوع و پویانمایی برای توصیف‌های رسمی نوشته شده به زبان Z است که برخی از نسخ بسط یافته Z مانند
Z- object، Circus و TCOZ را نیز پشتیبانی می نماید. از این ابزار می توان جهت توصیف دقیق نیازمندی های سیستم یا توصیف رفتاری سیستم و تحلیل رفتار از طریق اقیات، پویانمایی، تولید آزمون و وارسی استفاده نمود. 

###
روش مبتنی بر رخداد،Event – B

روش Event – B نیز برای اولین بار توسط Abrial در سال ۱۹۹۶ ارائه گردیده است. در مقایسه با زبان Z این روش بیشتر بر پالایش کد تمرکز داشته و به همین خاطر تبدیل توصیف‌های آن به پیاده سازی راحت تر صورت می گیرد و همچنین در مقایسه با زبان ، این روش دارای ابزار توسعه یافته تری است. 

مدل: 

روش Event – B از یک مفهوم پایه به نام مدل برای توصیف رسمی خود استفاده می نماید. یک مدل شامل عناصر متعدد از نوع ماشین و متن است. ماشینها معرف قسمت پویای مدل، وضعیت کنونی سیستم و دربرگیرنده متغیرها، قيود، قضایا و رخدادها است. مفاهیم، معرف قسمت ایستای مدل و دربرگیرنده داده‌ها، ثابت‌ها و وجوه بدیهی است که در طول توسعه سیستم استفاده میشود.

رخداد:

 روشEvent -B (همان طور که نام آن نشان می دهد) با استفاده از رخدادها به توصیف یک سیستم می پردازد. از این رو در دسته روش‌های مبتنی بر رخداد قرار می گیرد. در این روش رسمی، رخدادها بیانگر عملیات وابسته به ماشین ها بوده و از طریق همین رخدادها سیستم با محیط پیرامون خود تعامل خواهد داشت. یک رخداد می تواند شامل مجموعه ای از پیش شرطها و مجموعه ای از کنش‌ها بوده که به وسیله آنها متغیرها مقداردهی می شوند. یک رخداد در این روش با شکل 9 بیان می شود. در این رابطه که بیانگر کنش ها و نماینده متغیرهایی است که در طول رخداد مقداردهی می شوند.

evt = BEGINS(v)END

پیمانه:

روش Event – B با استفاده از مدل ها، توانایی توصیف بخشهای مختلف سیستم را به صورت پیمانه ای داراست. به طور مثال در (10) و (11) فاکتور ۱ توصیف می شود. این فاکتور شامل نوعی محصول (Product1) است و دارای مجموعه سفارش ها و موقعیت آنها (سفارشهای در حال انتظار و سفارش های فاکتور شده) است و include نشان می دهد که این فاکتور شامل ۱ Product است.  Product1 خود جزء دسته محصول ها بوده و در توصیف آن از متغیرهای محصول و تعداد موجودی انبار با این قید که هر دو در ابتدا دارای مقدار صفر هستند استفاده شده است.


###
![image](https://user-images.githubusercontent.com/106925008/172068905-5d9aeec4-24e9-4c08-8e1e-4863fe6bec3e.png)
###

پالایش:

 ویژگی کلیدی این روش استفاده از پالایش مدل بوده که توسعه افزایشی مدل ها را از مدل متنی اولیه فراهم می سازد. در این روش در هر توسعه، صحت توصیف ها در مدل پالایش یافته جدید با استفاده از قواعد استنتاجی تضمین می شود. برای مثال یک پل عبور یک طرفه از جزیره اصلی به یک جزیره فرعی را در نظر میگیریم. این پل حداکثر ظرفیت عيور همزمان d ماشین را دارد و n تعداد واقعی ماشین ها در یک لحظه از زمان در روی پل و جزیره فرعی می باشد و متغیر و تعداد ماشین هایی است که از روی پل به سمت جزیره فرعی حرکت کرده و متغیر ا تعداد ماشین هایی است که در جزیره فرعی هستند و متغیر و تعداد ماشین هایی است که از روی پل به سمت جزیره اصلی در حرکت هستند. توصیف اولیه با توجه به موارد گفته شده به صورت (12) تا (14) است. قید ۱، ۲ و ۳ در (13) به حقیقی بودن جنس سه متغیرb ،aو c اشاره دارد. قید ۴ در (14) اظهار می دارد که جمع تعداد ماشین ها بر روی پل و جزیره برابر با n است و چون پل یک طرفه است، به طور همزمان با تعداد ماشین ها روی پل به سمت جزیره (a) برابر صفر بوده یا تعداد ماشین ها روی پل به سمت بیرون جزیره (c) برابر صفر است (قید ۵). رخداد خروج ماشین ها از جزیره اصلی ( ML_OUT) را در شکل 15 توصیف می کنیم.


constant:d 


variables: a,b,c


![image](https://user-images.githubusercontent.com/106925008/172069002-35a7defb-d299-4d34-8211-8a2c1ff3f66f.png)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;شکل 15: توصیف یک رخداد در روش Event-B




![image](https://user-images.githubusercontent.com/106925008/172069036-d2726bd8-12c8-4126-842b-733285aa70f0.png)



شکل 15 اظهار می دارد که رخداد خروج ماشین از جزیره اصلی و حرکت به سمت جزیره فرعی به معنای افزایش یک واحدی تعداد مجموع ماشین ها (n) است به این شرط که تعداد آنها از حداکثر ظرفیت (d) تجاوز نکند. پالایش شکل 15 در شکل16نشان داده شده است. شکل 16 اظهار می دارد که رخداد، خروج ماشین از جزیره اصلی و حرکت به سمت جزیره فرعی زمانی صورت می گیرد که تعداد ماشین های روی پل که به سمت جزیره فرعی در حرکت هستند (a)، به همراه ماشین های روی پل (b) کمتر از حداکثر ظرفیت (d) باشد. چون پل یک طرفه است، اگر ماشینی قصد حرکت به سوی جزیره فرعی را دارد باید تعداد ماشین های در حال خروج از جزیره فرعی (c) صفر باشد و با حرکت این ماشین، به تعداد ماشین هایی که به سمت جزیره فرعی حرکت می کنند (a) یکی اضافه شود.



همروندی و همگامی:

یکی از نقاط ضعف این روش عدم پشتیبانی توصیف فرایندهای همگام و همروند است. پشتیبانی ابزاری برای این روش ایزاری با نام Rodin Platform ارائه شده است که این ابزار، تجمیعی از چندین ابزار جهت پوشش مراحل مختلف توسعه نرم افزار می باشد. این ابزار مراحل توصیف، تحلیل، اثبات، بررسی مدل و مستندسازی را به صورت خودکار پشتیبانی می نماید.
 روش منطقی: منطق زمانی بی درنگ
 منطق زمانی بی درنگ یک زبان منطق رتبه اول بوده که اولین بار توسط Jahanian و Moh در سال ۱۹۸۶ ارائه گردیده است. این روش در ابتدا برای استدلال درباره ویژگی های زمانی سیستم های بلادرنگ ایجاد شده است. در این روش با یک گزاره، رخدادهای یک سیستم به زمان وقوع آنها وابسته شده و یک سیستم بلادرنگ به صورت کلاسی از انواع رخدادها مدل می گردد. مشکل اصلی این روش این است که وارسی فرمول های منطق زمانی بی درنگ کار بسیار مشکلی بوده چون تعداد نامحدودی از وقوع رخدادها بایستی در نظر گرفته شوند.


منطق و رخداد:

در روش منطق زمانی بیدرنگ، رخدادهای یک سیستم به وسیله فرمول های منطقی توصیف می شوند و به همین خاطر این روش هم در دسته روشهای مبتنی بر منطق و هم در دسته روشهای مبتنی بر رخداد قرار می گیرد. به طور مثال می خواهیم یک سیستم که شامل تولید کننده و مصرف کننده است را مرد با این روش توصیف نماییم. در این مثال تولید کننده در ابتدای هر فاصله زمانی به اندازه p واحد، پیامی را در حافظه قرار میدهد. مصرف کننده، پیام را از حافظه پاک نموده و در هر فاصله زمانی از p پیام برداشته شده را مورد پردازش قرار میدهد. علاوه بر این مصرف کننده برای پردازش پیام به ، c واحد زمانی نیاز دارد. از آنجایی که تولید کننده و مصرف کننده روی پردازنده های متفاوتی قرار گرفته اند، ساعت مصرف کننده به اندازه a واحد زمانی عقب تر از ساعت تولیدکننده می باشد. توصیف این سیستم با روش منطق زمانی بی درنگ با (16) تا (18) ارائه می شود.



![image](https://user-images.githubusercontent.com/106925008/172069061-fe432332-c6f1-4e8d-8c19-aa84e0ebfdcc.png)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;پالایش یک رخداد در روش Event-B


![image](https://user-images.githubusercontent.com/106925008/172069066-6fb5d3d2-3af1-4d6f-96cd-e2dd48b20c51.png)



رخداد P در توصیف این سیستم نمایانگر درج یک پیام در حافظه توسط تولید کننده در فواصل زمانی
p  بوده و رخداد Q بالا نشان دهنده برداشته شدن پیام و شروع پردازش یک پیام توسط مصرف کننده و رخداد Q پایین بیانگر کامل شدن پردازش پیام توسط مصرف کننده می باشد.

زمان:
 
در این روش همان طور که در مثال تولید کننده - مصرف کننده دیده شد امکان توصیف زمان به صورت کمی وجود دارد. برای مثال در توصیف ارائه شده (خط چهارم) بیان شده که مدت زمان شروع مصرف تا پایان مصرف، c واحد زمانی می باشد.

قابلیت اثبات:

 از مزایای دیگر این روش بهره بردن از فرمولهای منطقی بوده که قابلیت اثبات را برای توصیف های این روش فراهم می سازد. به طور مثال برای یک سیستم تولید کننده - مصرف کننده که در (16) تا (18) توصیف
گردید، قید ایمنی برای گزاره "عمليات شروع مصرف Q بالا نمونه iام توسط مصرف کننده باید قبل از تولید نمونه (۱+i) ام توسط تولید کننده صورت گیرد" را با (19) نشان می دهیم


![image](https://user-images.githubusercontent.com/106925008/172069153-e901da11-4799-4d99-b1ba-f8b54a203ebb.png)


حال با استفاده از برهان خلف به اثبات (19) می پردازیم. توصیفهای تولید کننده به مصرف کننده را با (SP)(a-20) تا (e-20) و نقیض قید ایمنی را با (SA)(f-20) نشان می‌دهیم.


![image](https://user-images.githubusercontent.com/106925008/172069168-035d6143-48a9-4691-943a-bb83bfa0171d.png)


پیمانه و وراثت:

 روش منطق زمانی بی درنگ دارای امکان شکستن توصیف های بزرگ به بخش های کوچک تر نبوده و به همین دلیل توانایی پیمانه سازی ندارد. علاوه بر آن، نماد نحوی جهت پشتیبانی از مفاهیم شیء گرایی برای این روش ارائه نشده است. 

پشتیبانی ابزاری:

 این روش دارای ایزار جهت توصیف یا تغییر توصیف و اعتبارسنجی نبوده و تنها ابزار موجود برای این روش Verify4 است که در قسمت وارسی توصیف به کار میرود. 


روش جبری: CSP

 روش CSP در سال ۱۹۷۸ توسطC.A. Hoareمعرفی گردید. این روش یک روش رسمی با نمادهای متنی جهت توصیف و تحلیل سیستم های همروند بوده که در آن مؤلفه های فرایندها از طریق ارتباط بر یکدیگر اثر متقابل دارند. این روش متعلق به خانواده نظریه ریاضی همروند بوده که به عنوان پردازش جبری یا Process Calculus شناخته شده است. این روش می تواند همگامی بین فرایندهای همروند) همگامی زمانی اتفاق می افتد که در فرایند قصد داشته باشند به صورت همگام پیامی را ارسال و دیگری دریافت نماید) را مدل نماید .چون این روش بر پایه نظریه ریاضی است، می تواند جهت استدلال نیز مورد استفاده قرار گیرد
جبر مبتنی بر رخداد:
 نوع نمادهای مورد استفاده در این روش هم متنی و هم ریاضی می باشد. تمرکز این روش برای توصیف یک نرم افزار با استفاده از قوانین جیری برای بیان فرایندها بوده و آنچه در توصیف یک نرم افزار مورد اهمیت قرار می گیرد رخدادهای موجود می باشند. به این خاطر این روش هم در دسته روش های  مبتنی بر رخداد و هم در دسته روش‌های جبری قرار می گیرد. نمادهای منطقی که در این روش استفاده می شوند در شکل ۲1 ارائه شده است. 


![image](https://user-images.githubusercontent.com/106925008/172069221-6067795a-7b0a-4bc0-91ad-9ad2925b29b3.png)


پیمانه سازی:

در روشCSP امکان شکستن توصیفهای بزرگ به پیمانه های کوچکتر و امکان توصیف سلسله مراتبی وجود دارد. به طور مثال می توان ابتدا بیان کلی از یک نرم افزار ارائه نمود و سپس در توصیفهای بعدی جزئیات را مشخص کرد. مثالی برای روشن شدن مطلب ارائه می شود. اولین گزاره  اظهار می دارد که سیستم عامل (OP) از یک نرم افزار دسته ای (BATCH) و یک سامانه ورودی خروجی (IOSYSTEM) تشکیل شده است و دومین گزاره سامانه ورودی خروجی را توصیف می کند. در این سامانه ورودی خروجی یک فایل سیستمی (filesys) بین خط پرینتر (p) از قسمت خروجی و بین کارتخوان (cr) از قسمت ورودی به اشتراک گذاشته شده است.



![image](https://user-images.githubusercontent.com/106925008/172069233-c2145585-00cb-4350-a601-68e28e600678.png)


