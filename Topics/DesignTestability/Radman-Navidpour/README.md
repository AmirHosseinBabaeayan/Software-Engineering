# آزمون پذیری طراحی
## رادمان نویدپور
### چکیده
آزمون پذیری طراحی در بسیاری از پروژه های نرم افزاری آزمون و خطایابی (Debugging) نرم افزار پرهزینه ترین مرحله در چرخه زندگی این محصول محسوب می گردند. از سوی دیگر در صورت نامناسب بودن طراحی در روش های شی گرا، آزمون رده ها (Classes) می تواند به کاری بسیار دشوار تبدیل شود. در نتیجه آزمون پذیر بودن یک طراحی شی گرا می تواند نقش به سزایی را در کاهش هزینه های مرحله آزمون و تسهیل آن ایفا نماید.

**کلیدواژه ها** : آزمون پذیری، شی گرایی، برنامه نویسی، باگ، خطایابی، طراحی
### مقدمه
خطایابی پروژه اساساً فرآیندی است که با استفاده از آن هرگونه اشکال موجود در یک نرم افزار یا برنامه را برطرف می کنیم. در این مرحله ابتدا خطاها را شناسایی و سپس تجزیه و تحلیل و حذف می کنیم. خطایابی پس از عدم اجرای صحیح نرم افزار مورد نظر آغاز می شود. در اینجا با حل مشکل و تست موفقیت آمیز نرم افزار به نتیجه می رسیم. این فرآیند بسیار خسته کننده و پیچیده در نظر گرفته می شود زیرا ما باید خطاهای موجود در هر مرحله از خطایابی را شناسایی و برطرف کنیم در ادامه آزمون فرآیندی است که با استفاده از آن تأیید می‌کنیم که یک برنامه یا نرم‌افزار عاری از اشکال است، همه الزامات فنی را برآورده می‌کند، از همه الزامات توسعه و طراحی پیروی می‌کند، و همه الزامات کاربر را برآورده می‌کند. آزمایش تضمین می‌کند که نرم‌افزار/برنامه مورد نظر این الزامات را به طور مؤثر و مؤثر برآورده می‌کند و همه موارد مرزی و موارد استثنایی را مدیریت می‌کند.
آزمون پذیری طراحی رویه‌ای است که برای تنظیم فرآیند توسعه برای حداکثر اثربخشی تحت یک طرح مبتنی بر منابع محدود یا مبتنی بر قابلیت اطمینان استفاده می‌شود. یک فرآیند با منابع محدود از یک رویکرد آزمایشی برای به دست آوردن نتایجی استفاده می کند که هدف قابلیت اطمینان پیش از انتشار محقق شده است. این فرآیند آزمایش را راهی برای حذف هر چه بیشتر اشکال از یک سیستم می‌داند تا وقتی که زمان یا پول اجازه می‌دهد. آزمایش پذیری یا برای کاهش هزینه در یک فرآیند مبتنی بر قابلیت اطمینان قابل توجه است و همچنین برای افزایش قابلیت اطمینان در یک فرآیند با منابع محدود.
### چرا باید به آزمون پذیری در طراحی خود اهمیت بدهیم؟



![istockphoto-1281034045-612x612](https://user-images.githubusercontent.com/46504963/172053233-d8571f72-112e-45aa-89b4-d0e683bb3ffe.jpg)

هنگام طراحی نرم افزار، یاد می گیرید که به آنچه نرم افزار باید انجام دهد و نتایجی که برای کاربر نهایی سیستم خواهد داشت فکر کنید. اما تست‌ها در برابر نرم‌افزار شما نوع دیگری از کاربر است. آن کاربر خواسته های سختگیرانه ای برای نرم افزار شما دارد، اما همه آنها از یک درخواست مکانیکی ناشی می شوند: قابلیت آزمایش. این درخواست می تواند به طرق مختلف بر طراحی نرم افزار شما تأثیر بگذارد و عمدتاً برای بهتر شدن نرم افزار هستند.
در یک طراحی قابل آزمون، هر قطعه کد منطقی (حلقه‌ها، ifها، سوئیچ‌ها و غیره) باید آسان و سریع باشند برای اینکه روی آن ها بتوانیم یک یونیت تست بنویسیم.
به طور کلی این ویژگی ها را داشته باشد:
سریع اجرا شود
ایزوله است.
به پیکربندی خارجی نیاز ندارد
نتیجه قبولی/رد ثابتی را ارائه می دهد
اینها ویژگی های FICC هستند: سریع، ایزوله، بدون پیکربندی و سازگار. اگر نوشتن چنین تستی سخت است، یا نوشتن آن زمان زیادی می برد، سیستم قابل آزمایش و آزمون نیست. اگر به تست‌ها به‌عنوان کاربر سیستم خود فکر می‌کنید، طراحی برای آزمون‌پذیری تبدیل به یک روش فکری می‌شود. اگر توسعه مبتنی بر آزمون را انجام می‌دادید، چاره‌ای ندارید جز اینکه یک سیستم آزمونپذیر بنویسید، زیرا در TDD، آزمایش‌ها در درجه اول قرار می‌گیرند و تا حد زیادی طراحی API سیستم را تعیین می‌کنند و آن را مجبور می‌کنند تا چیزی باشد که تست‌ها بتوانند با آن کار کنند. . اکنون که می‌دانید طراحی قابل آزمون چیست، اهداف طراحی ازمون پذیر را بررسی کنیم.

### اهداف طراحی برای آزمایش پذیری
![download](https://user-images.githubusercontent.com/46504963/172053388-53287501-7b1f-4c70-935e-46eed0586a95.jpg)

#### متد ها به صورت پیش فرض مجازی باشند

این به شما اجازه می دهد تا روش های موجود در یک مشتق شده را لغو کنیدکلاس برای تست نادیده گرفتن امکان تغییر رفتار یا قطع تماس به یک وابستگی خارجی را فراهم می کند.

#### استفاده از طرح مبتنی بر رابط
این به شما امکان می‌دهد از چندشکلی برای جایگزینی دیپندنسی ها در سیستم با موارد خرد یا ساختگی خود استفاده کنید.


#### کلاس ها را به طور پیش فرض غیر مهر و موم کنید
اگر کلاس مهر و موم شده باشد نمی توانید چیزی مجازی را لغو کنید. (final در جاوا) 


#### از نمونه سازی کلاس های Concrete در روش های منطقی خودداری کنید
این به شما این امکان را می‌دهد تا نمونه‌های جعلی خود را از کلاس‌ها به روش‌هایی که به آن‌ها نیاز دارند، ارائه دهید، به‌جای اینکه به یک نمونه تولید داخلی یک کلاس وابسته باشید.


#### از کال کردن مستقیم  متد های استاتیک خودداری کنید
این به شما امکان می‌دهد تا تماس‌های متدهای استاتیک را با استفاده از روش‌های نمونه لغو کنید.


#### از کانستراکتورها و کانستراکتورهای استاتیک که اعمال منطقی را انجام می دهند اجتناب کنید
ساده نگه داشتن کانستراکتور ها، کار ارث بردن از یک کلاس را در تست های شما ساده می کند.


#### لاجیک تکی را از نگهدارنده های تکی جدا کنید
اگر سینگلتون دارید، راهی برای جایگزینی نمونه آن داشته باشید تا بتوانید سینگلتون را تزریق کنید یا آن را ریست کنید.

### مزایا و معایب طراحی آزمون پذیر
![download](https://user-images.githubusercontent.com/46504963/172053619-54f5ee26-237d-45c8-8e46-3569f210734a.png)

برخی بر این باورند که آزمایش پذیری باید یکی از ویژگی های پیش فرض طرح ها باشد، و برخی دیگر معتقدند که طرح ها نباید فقط به این دلیل که کسی باید آنها را آزمایش کند، "مشکلات" داشته باشد. نکته ای که باید متوجه شد این است که آزمایش پذیری به خودی خود یک هدف نهایی نیست، اما صرفاً محصول جانبی یک مکتب طراحی خاص است که از اصول شی گرا قابل آزمایش تر ارائه شده است استفاده می کند. در طرحی که به نفع توسعه پذیری و انتزاع کلاس است، یافتن درزهایی برای اقدامات مرتبط با آزمون آسان است.
این سؤال باقی می ماند، آیا این بهترین راه برای انجام کارها است؟ معایب چنین روش طراحی مبتنی بر آزمایش پذیری چیست؟ وقتی کد قدیمی دارید چه اتفاقی می‌افتد؟ و غیره.
####حجم کار
در بیشتر موارد، طراحی برای آزمایش پذیری بیشتر از این نیاز دارد زیرا انجام این کار معمولاً به معنای نوشتن کد بیشتر است. می‌توانید استدلال کنید که کار طراحی اضافی مورد نیاز برای آزمایش‌پذیری، به مسائل طراحی اشاره می‌کند که شما در نظر نگرفته‌اید و ممکن است از شما انتظار می‌رود به هر حال در طراحی خود بگنجانید (تفکیک نگرانی‌ها، اصل مسئولیت تک‌مسئولیت، و غیره). از سوی دیگر، با فرض اینکه از طراحی خود راضی هستید، ایجاد تغییرات برای آزمایش پذیری، که بخشی از تولید نیست، می تواند مشکل ساز باشد. مجدداً، می‌توانید استدلال کنید که کد آزمایشی به اندازه کد تولید مهم است.
####پیچیدگی
طراحی برای آزمایش‌پذیری گاهی اوقات می‌تواند کمی (یا خیلی زیاد) به نظر برسد که چیزها را بیش از حد پیچیده می‌کند. می‌توانید متوجه شوید که رابط‌هایی را اضافه می‌کنید که در آن استفاده از اینترفیس‌ها طبیعی به نظر نمی‌رسد یا معنایی رفتار کلاسی را که قبلاً در نظر نمی‌گرفتید، آشکار کنید. به ویژه، زمانی که بسیاری از چیزها دارای رابط هستند و انتزاع می شوند، پیمایش در پایه کد برای یافتن پیاده سازی واقعی یک روش می تواند دشوارتر و آزاردهنده تر شود.
####افشای موارد حساس
بسیاری از پروژه‌ها دارای مالکیت معنوی حساسی هستند که نباید افشا شود، اما طراحی برای آزمایش‌پذیری مجبور به افشای آن‌ها می‌شود: به عنوان مثال، اطلاعات امنیتی یا مجوز، یا شاید الگوریتم‌های تحت اختراع. راه‌حل‌هایی برای این کار وجود دارد  اما آنها اساساً کل مفهوم آزمایش‌پذیری در طراحی را به چالش می‌کشند. شما طراحی را تغییر می دهید اما هنوز منطق را پنهان نگه می دارید. مسئله بزرگ اینجاست که طراحی برای آزمایش پذیری کمی شروع به از بین رفتن می کند. گاهی اوقات نمی‌توانید مسائل امنیتی یا حق ثبت اختراع را حل کنید. شما باید کاری را که انجام می دهید تغییر دهید یا در روش انجام آن مصالحه کنید.
####موارد دیگر
گاهی اوقات دلایل سیاسی یا دلایل دیگری وجود دارد که طراحی به روش خاصی انجام شود، و شما نمی توانید آن را تغییر دهید یا اصلاح کنید. گاهی اوقات شما زمان لازم برای بازسازی طرح خود را ندارید، یا اینکه طرح برای بازسازی آن خیلی شکننده است. این مورد دیگری است که در آن طراحی برای آزمایش‌پذیری خراب می‌شود – زمانی که محیط از شما جلوگیری می‌کند. اکنون که برخی از جوانب مثبت و منفی را بررسی کردیم، می خواهیم که جایگزین هایی را برای طراحی برای آزمایش پذیری در نظر بگیریم.
### جمع بندی
در این مقاله، به ایده طراحی برای آزمایش‌پذیری نگاه کردیم: چه چیزی از نظر تکنیک‌های طراحی، مزایا و معایب آن، و جایگزین‌های انجام آن را شامل می‌شود. هیچ پاسخ آسانی وجود ندارد، اما سوالات جالب هستند. آینده آزمایش واحد بستگی به نحوه برخورد افراد با چنین مسائلی و اینکه چه ابزارهایی به عنوان جایگزین در دسترس است، خواهد داشت. طرح‌های قابل آزمایش معمولاً فقط در زبان‌های ایستا مانند C# یا VB.NET اهمیت دارند، جایی که آزمایش‌پذیری بستگی به انتخاب‌های طراحی فعال دارد که امکان جایگزینی چیزها را فراهم می‌کند. طراحی برای آزمایش پذیری در زبان های پویاتر اهمیت کمتری دارد، جایی که موارد به طور پیش فرض بسیار بیشتر قابل آزمایش هستند. در چنین زبان هایی، بدون توجه به طراحی پروژه، اکثر چیزها به راحتی قابل تعویض هستند. این امر جامعه چنین زبان‌هایی را از این بحث مرد کاه که آزمایش‌پذیر نبودن کد به معنی بد طراحی شدن آن است خلاص می‌کند و به آن‌ها اجازه می‌دهد تا روی آنچه طراحی خوب باید در سطحی عمیق‌تر به دست بیاورند تمرکز کنند. طرح‌های آزمایش‌پذیر دارای روش‌های مجازی، کلاس‌های غیر مهر و موم شده، رابط‌ها هستند. آنها کلاس ها و متدهای استاتیک کمتری دارند و نمونه های بیشتری از کلاس های منطقی دارند. در واقع، طرح‌های قابل آزمایش با اصول طراحی SOLID مرتبط هستند، اما لزوماً به این معنی نیست که شما طراحی خوبی دارید. شاید زمان آن فرا رسیده باشد که هدف نهایی نباید آزمایش پذیری باشد، بلکه طراحی خوب به تنهایی باشد. ما به نمونه کوتاهی نگاه کردیم که بسیار غیرقابل آزمایش است و تمام مراحلی که برای تبدیل آن به آزمایش پذیری باید انجام شود.
### مراجع
##### کتاب هنر یونیت تست ، نسخه دوم 
##### کتاب رشد نرم افزار شی گرا، هدایت شده توسط تست ها ،استیون فریمن
##### ویکیپدیا
##### مقاله خطایابی:بررسی از منظر اموزشی
##### مقاله خطایابی مدرن
##### مقاله اصول OOD
