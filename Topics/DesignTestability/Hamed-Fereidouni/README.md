
**مهندسی نرم افزار**
-----------
## عنوان : آزمون ‍‍پذیری نرم افزار
### گردآورنده : حامد فریدونی
----------------

**مقدمه**

  

پروژه های نرمافزار معموال همراه با مهلت های تعیین شده انجام می شود و با زمان قابل توجهی که صرف بخش توسعه می شود، مرحله تست بدون زمان کافی باقی می ماند. به این ترتیب، براورد هزینه و زمان مورد نیاز آزمون، قبل از شروع آن ممکن است در برنامهریزی و سازماندهی فعالیت های مختلف آزمون به منظور رعایت مهلت های داده شده مفید باشد.

  

**آزمون پذیری نرم افزار چیست؟**

  

آزمون پذیری، وضعیت محصول نرم افزار است که سطح دشواری انجام فعالیت های آزمایشی روی آن محصول را تعیین می کند. این محصولات نرم افزاری ممکن است شامل ماژول های نرمافزار، مدل های UML ، الزامات و اسناد طراحی و خود برنامه نرم
افزاری باشد.

  
آزمون پذیری به تعیین هزینه و زمان مورد نیاز برای اجرای فعالیتهای آزمایشی روی یک محصول نرم افزاری ، کمک میکند. هزینه ها ممکن است از نظر ورودی های مورد نیاز در تست ها مانند پوشش سناریوهای تست، تعداد موارد تست، مدت زمان،
منابع آزمون و غیره در نظر گرفته شوند.

  

اساساً آزمون پذیری، ویژگی اساسی مرتبط با هر یک از محصوالت نرم افزاری است که امکان محاسبه هزینه مورد نیاز برای انجام آزمایش را فراهم می کند. هرچه آزمون پذیری کمتر باشد، هزینه ها بیشتر خواهد بود در حالی که آزمون پذیری بیشتر حداقل
هزینه را تضمین می کند.

  

آزمون پذیری در نرم افزار نه تنها به معنای قابل تست بودن است ، بلکه به معنای آسان بودن فرایند تست نیز میباشد.
  

هزینه و اثربخشی تست های نرم افزاری به عوامل متعددی بستگی دارد از جمله:

  

- ویژگی های مورد نیاز نرم افزار

- ویژگی های خود نرم افزار )مانند اندازه، پیچیدگی و تست پذیری(

- ویژگی های روش های آزمایشی مورد استفاده

- ویژگی های فرآیندهای توسعه و آزمایش

- صلاحیت و انگیزه افراد درگیر در فرآیند آزمون

  

` `**software testing و software testability تفاوت**

  

` `**Software Testing**

  

فرآیندی است که برای یافتن نقص های سیستم استفاده می شود. به عبارت دیگر، فرآیند تأیید این است که یک محصول نرم افزاری در نسخه نهایی بدون باگ باشد. هدف اصلی تست نرم افزار بررسی کیفیت محصول نرم افزاری است.

  

انواع مختلفی از روش های تست نرم افزار وجود دارد. روشهای فانکشنال و غیر فانکشنال که برای بررسی AUT در اینجا استفاده میشوند. به عنوان مثال تست واحد )Unit test(، تست یکپارچه سازی، تست آلفا، تست پذیرش و غیره.

  

` `**Software Testability**

  

به این معنی است که هر یک از ماژول های نرم افزار را می توان تست کرد. بررسی صحت خروجی نرم افزار نیست. غیر از این که تست پذیری نرم افزار یکی از ویژگی های یک نرم افزار است، پس مشخص میشود که نرم افزار می تواند تست شود یا خیر.

  

تعیین تست پذیری پوشش استراتژی های تست مانند پوشش شاخه برای تست جریان کنترل )Control flow( است. می

  

تواند تعریف کند که تطابق با ورودی ها و خروجی ها وجود دارد یا خیر.

  

برخی از باورهای مرتبط با آزمونپذیری عبارتند از :

  

-  **آزمون پذیری بسیار هزینه بردار است**

  

برخی معتقدند که آزمون پذیری گران تر است. بنابراین آنها رویکردی برای دستیابی به قابلیت تست نرم افزار در مراحل اولیه مراحل توسعه ندارند، فقط برنامه را در مرحله آزمایش، آزمایش کنید. اما تست پذیری نرم افزار خیلی
گران نیست. با سرمایه گذاری اندک در مراحل توسعه می توان تشخیص خطا در نرم افزار را افزایش داد. بدون سرمایه گذاری تست پذیری، بازگشت به مراحل قبلی و اصالح باگ ها روش بسیار پرهزینه تری است.

  

-  **همه نرم افزار ها نمیتوانند آزمون پذیر باشند**

  

این برداشت نیز کامال اشتباه است. به خصوص برخی فکر می کنند که پروژه های نرم افزاری با بودجه کم نمی توانند با آزمایش پذیری سازگار شوند. اگر این نوع برنامه ها به آزمایش پذیری نرسند، هزینه پروژه را بالا می برد و برای تیم
پروژه نیز مشکل ایجاد می کند.

  

-  **آزمونپذیری را میتواند رد کرد و انجام نداد**

  

تست پذیری در مرحله اول توسعه شروع شود. آزمونپذیری ویژگیای ست که کیفیت برنامه را بهبود می بخشد. ویژگی مانند کیفیت نمی تواند مانند یک ماژول جداگانه با محصول ادغام شود. بنابراین نیاز به اجرای متوالی است.

  

در نتیجه تمامی این باور های اشتباه میتوانند با دلایل معقول رد شوند.

  

**کاربرد مفهوم آزمون پذیری در مراحل توسعه نرم افزار**

  

آزمونپذیری نرم افزار از ویژگی های نرم افزار نیست که بتوان آن را در یک فاز به ویژه مرحله تست، توسعه داد. باید از طریق چرخه عمر توسعه نرم افزار آن را بهبود بخشید. در غیر این صورت قادر به دستیابی به آزمون پذیری نرم افزار از محصول نرم
افزاری نهایی نخواهیم بود.

  

**آزمون پذیری نرم افزار چگونه اندازه گیری میشود؟**

  

برخی از روش هایی که میتوان با استفاده از آنها آزمون پذیری یک نرمافزار را مشخص کرد عبارتاند از :**

  

-  **کنترل پذیری:** درجه ای که می توان وضعیت قطعه مورد آزمایش )Component Under Test( را بر اساس نیاز برای آزمایش کنترل کرد.

-  **مشاهده پذیری:** میزان امکان مشاهده نتایج آزمون )متوسط و نهایی(.

-  **مستقل بودن:** درجه ای که می توان جزء تحت آزمایش )Component Under Test( را به صورت مجزا آزمایش کرد.

-  **تفکیک نگرانی ها:** درجه ای که جزء تحت آزمایش یک مسئولیت واحد و کامالً مشخص دارد.

-  **قابل درک بودن:** درجه ای که جزء مورد آزمایش مستند یا خود توضیح )Self-explaining( است.

-  **قابل خودکار شدن:** درجه ای که امکان تست خودکار جزء مورد آزمایش وجود دارد.

-  **ناهمگونی:** درجه ای که استفاده از فناوری های گوناگون، مستلزم استفاده همزمان از روش ها و ابزارهای آزمایشی گوناگون است. یعنی برای استفاده از یک فناوری متفاوت برای آزمون، روش ها و ابزار های متفاوتی نیز باید استفاده شود تا قابلیت آزمون فراهم باشد.

  

**مزایای کلیدی تست پذیری نرم افزار**

  

- پیدا کردن ایرادات نرم افزار را برای تسترها ) Test Engineers ( راحت تر میکند.

- محدوده آزمایش خودکار روی محصول نرم افزاری را بر اساس قابلیت کنترل آن تعیین می کند.

- افزایش قابلیت تست، تشخیص آسان و زودهنگام باگ ها را تضمین می کند، در نتیجه باعث صرفه جویی در زمان و هزینه می شود.

- هزینه و زمان مورد نیاز تستر ها برای انجام آزمون محاسبه و کنترل کرده و به حداقل میرساند.

  

**چگونه آزمون پذیری را بهبود ببخشیم؟**

  

بگذارید از نیازمندی ها شروع کنیم :

  

-  **آزمون پذیری نیازمندی ها**

  

نیازمندی های شما چقدر از تست نرم افزار شما پشتیبانی می کند؟نیازمندی های خوب، پیش نیاز آزمونپذیری است. این نیازمندی ها درک واضح، مشترک و منسجمی از نتایج مورد انتظار اعتبارسنجی ایجاد می کنند. نیازمندی ها، فعالیتهای آزمایشی را هدایت میکنند و باید ویژگیهای زیر را برای افزایش تستپذیری داشته باشند:

  

-  **کامل بودن:** یک نیازمندی زمانی کامل می شود که حاوی جزئیات کافی برای هدایت کل فرآیند توسعه باشد - از جمله آزمایش)Test(. با این حال، ممکن است تصمیم بگیریم که نیازمندی های مختلف را ننویسیم. اما این باعث ناقص بقودن نمیشود، تا زمانی که آن نیازمندی ها از قبل شناخته شده و به خوبی درک شده باشند. مسئله بزرگ برای کامل بودن، نیازمندی های نانوشته ای است که باید بنویسیم، اما متوجه آن نیستیم. این اغلب به ریسک در مقابل پاداش ختم می شود. نیازمندی ها چقدر باید کامل باشند تا فعالیتهای آزمایشی را در سطح ریسک قابل قبولی هدایت کنند؟**

-  **مختصر بودن:** یک نیازمندی زمانی مختصر است که به یک موضوع واحد بپردازد و فقط حاوی اطالعات الزم باشد که در کمترین کلمه ممکن بیان شده باشند. فقدان اختصار می تواند ناشی از دستور زبان بیش از حد پیچیده، عبارات ترکیبی یا منطق تعبیه شده و یا طراحی باشد – که فقط روند آزمایش را کند می کند.**

-  **سازگاز بودن:** یک نیازمندی زمنی سازگار است که با هیچ یک از نیازمندی های دیگر در تضاد نباشد. نیازمندی های متناقض چیزهای مختلفی را در مورد رفتار یا کیفیت سیستم می گویند. سازگاری را میتوان با تکرار نکردن حاالت مختلف بهبود بخشید، اگر جایی به چیزی نیاز است به جای تکرار کردن آن ، از رفرنس آن استفاده کنیم.**

-  **صحیح بودن:** یک نیازمندی زمانی صحیح است که بدون خطا باشد. یک نیاز نادرست ممکن است به طور دقیق یک نیازنادرست را بیان کند یا یک نیاز واقعی را به اشتباه بیان کند. این وع خطاها معموالً توسط کارشناسان موضوع

  

` `کشف می شوند، اما ممکن است توسط سایر ذینفعان نیز شناسایی شوند. یک الزام باید با تمام منابع منبع )SMEs(

  

سازگار باشد و توسط همه ذینفعان مناسب بررسی و تایید شود.**

  

-  **قابل انجام بودن:** یک نیازمندی از طریق استفاده در محصوالت قبلی، از طریق تجزیه و تحلیل، یا ز طریق نمونه سازی به عنوان یک نیازمندی قابل انجام شناخته میشود. امکان سنجی اغلب در اوایل پروژه نادیده گرفته می شود )یا حداقل مورد تاکید قرار نمی گیرد(. با ارزیابی زودهنگام امکان سنجی، دادههایی در مورد اینکه ریسک در پروژه کجاست، به دست میآوریم، خواه ناشی از کمبود داده، فقدان تجربه، یا ریسک فنآوری به خوبی نشان داده شده )و درک شده( باشد. به تعویق انداختن این ارزیابی فقط احتمال تأثیر نامطلوب پروژه را افزایش می دهد. در نهایت متوجه میشوید که چه زمانی یک نیاز غیرممکن است – چرا زمانی که کاری میتوانید در مورد آن انجام دهید متوجه نشوید؟**

-  **ضروری بودن:** یک نیاز زمانی ضروری است که بتوان آن را به نیازی که توسط مشتری، کاربر نهایی یا سایر ذینفعان بیان شده است، ردیابی کرد. همچنین ممکن است توسط استراتژی کسب و کار، نقشه راه )Road map( یا نیازهای پایداری دیکته شود. نیازهای غیر ضروری منابع توسعه را هدر می دهند و کار کمی انجام می دهند اما پس از انتشار هزینه های پشتیبانی ایجاد می کنند. اگر نمی توانید نیازهای خود را حداقل به یکی از این منابع ردیابی کنید، آن ها نباید در مشخصات باشند. این مسئولیت شماست که وجود الزامات و ویژگی هایی را که از این منابع نمی آیند زیر سوال ببرید. ممکن است دلیل خوبی وجود داشته باشد؛ اما معموال وجود ندارد.

-  **قابل ردیابی بودن:** یک نیاز در صورتی قابل ردیابی است که به طور منحصر به فرد و دائمی شناسایی شود. نیازمندی ها باید از موارد آزمایش، آزمایشها و نتایج آزمایش ردیابی شوند تا تجزیه و تحلیل پوشش تست را بهبود بخشد. ابزارهای خودکار مختلفی )مانند ویژوال استودیو( وجود دارد که شناسه های غیرقابل تغییر )مداوم( را برای هر نیاز اختصاص می دهند و قابلیت ردیابی را بین عناصر انجام می دهند.

-  **بدون ابهام بودن:** یک نیازمندی زمانی بدون ابهام است که برای مخاطب مورد نظر روشن باشد و دارای یک تفسیر واحد باشد. ابهام را می توان با تعریف اصطالحات، نوشتن مختصر، و اجتناب از کلمات ضعیف )آسان، سریع، و غیره(

  

و لیست های نامحدود )مانند، شامل، ...( کاهش داد. نمودارها، الگوریتمها، موارد استفاده، جداول یا سایر مصنوعات نیز میتوانند در صورت لزوم برای کاهش ابهام استفاده شوند.**

  

-  **قابل تایید بودن:** یک نیازمندی در صورتی قابل تأیید است که بتوان ثابت کرد که ب درستی اجرا شده است. اغلب غیرقابل تأیید است، زیرا مبهم است، نمی توان تصمیم گرفت، یا ارزش هزینه برای تأیید را ندارد. در صورت امکان، یک نیاز باید با استفاده از مقیاس مناسب اندازه گیری شود و از استفاده از عبارات نسبی مانند بزرگ، کوچک، سریع یا آهسته اجتناب شود. به عنوان مثال، شرطی مانند "زمان پاسخ کاربر باید سریع باشد" قابل تأیید نیست. شما باید کمیت شرایطی مانند "زمان پاسخ کاربر باید کمتر از ده ثانیه باشد" را تایید کنید. همچنین راستی آزمایی باید در عمل امکان پذیر باشد، نه فقط در تئوری.**

-  **آزمون پذیری اجزای نرم افزار**

  

یک جزء نرم افزار موجودیتی است متشکل از کالس های زیادی که می تواند به عنوان یک کتابخانه نیز استفاده شود، مانند JAR ،DLL یا Gem. رویکردی که ما در طراحی و نوشتن کالسها در اجزای خود در نظر میگیریم، میزان
پشتیبانی آنها از تست را تعیین میکند. ما می توانیم این آزمونپذیری را با بهبود کیفیت های زیر افزایش دهیم:

  

-  **کنترل پذیر بودن:** یک کامپوننت در صورتی قابل کنترل است که به راحتی بتوان وضعیت مولفه را همانطور که برای آزمایش الزم است دستکاری کرد. به عنوان مثال، یک توسعهدهنده خوب با ساختن کالسهایی با روشهایی که میتوانند توسط زیر کالسهای ویژه آزمون نادیده گرفته شوند، قابلیت تست را بهبود میبخشد. این به آنها اجازه می دهد تا هر رفتاری ا در آن کالس پایه اصالح یا حذف کنند و آزمایش آن را آسانتر میکند.**

-  **مستقل بودن:** یک جزء در صورتی مستقل است که بتوان آن را جدا از اجزای دیگر توسعه و آزمایش کرد. این ویژگی این امکان را فراهم می کند تا تست های یک جزء توسعه یافته و همزمان با آزمایش سایر مؤلفه ها اجرا شود. تیم های مختلف می توانند روی اجزای جداگانه به طور مستقل و بدون تداخل با یکدیگر کار کنند. مؤلفه ای که به طور قوی با سایر بخش های سیستم همراه است، به آزمایش های پیچیده تری برای تأیید عملکرد و تأیید کیفیت نیاز دارد.

-  **قابل درک بودن:** یک مؤلفه در صورتی قابل درک است که درک آنچه انجام می دهد آسان باشد، چه از طریق مستندات یا ز طریق خود کد. اگر یک جزء به خوبی درک نشود، نمی توان آن را به طور موثر آزمایش کرد.

  

**نتیجه : **

  

افزایش تست پذیری نرم افزار زمان و هزینه مورد نیاز برای برنامه ریزی، نوشتن، خودکارسازی و اجرای موارد تست را کاهش می دهد. تیم ش ا با افزایش پوشش کد و کشف ایرادات بیشتر، قبل از رفتن به تولید موثرتر خواهد بود. با نیاز به زمان کمتر، منابع کمتر و مجموعه های آزمایشی کوچکتر برای آزمایش همان مقدار کد، کارآمدتر باشید. و با توسعه تستهایی که سریعتر اجرا میشوند و قابلیت نگهداری و توسعهپذیری بیشتری را برای مجموعههای آزمایشی شما فراهم میکنند، سازندهتر باشید. بدون تغییر یک فرآیند واحد، این شیوههای توسعه منجر به بهبود کیفیت، هزینههای کمتر و زمان عرضه سریعتر به بازار خواهد
شد.

  

**منابع**

  

[https://www.powershow.com/view0/8d29f7- MzA0N/What_Is_Design_For_Testability_In_Software_Testing_powerpoint_pp t_presentation ](https://www.powershow.com/view0/8d29f7-MzA0N/What_Is_Design_For_Testability_In_Software_Testing_powerpoint_ppt_presentation)

  

[https://en.wikipedia.org/wiki/Software_testability ](https://en.wikipedia.org/wiki/Software_testability)[https://muuktest.com/blog/building-testability-in-software-engineering ](https://muuktest.com/blog/building-testability-in-software-engineering/)

[https://devlead.io/Articles/EnhancingSoftwareTestability ](https://devlead.io/Articles/EnhancingSoftwareTestability)
