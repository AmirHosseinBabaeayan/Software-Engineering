# Software Architecture
# چکیده

در این مقاله می خواهیم صحبتی درباره ی معماری میکروسرویس خوب بکنیم و ویژگیهایی که یک میکروسرویس خوب باید داشته باشد حرف خواهیم زد و درباره مزیت های آن توضیح خواهیم داد

## مقدمه

قبل از اینکه مستقیم درباره ی معماری میکروسرویس ها صحبت کنیم باید در مورد طراحی سیستمی (SystemDesign) و بعد معماری نرم افزار توضیحی دهیم که چیستند.

## طراحی سیستمی

مجموعه ای از پروسس های معماری نرم افزار و کامپوننت های آن نرم افزار و ارتباط این کامپوننت ها و دیتاهایی که بین اینها رد و بدل میشه است. در واقع می توانیم پروسسی طراحی کنیم که نیاز کاربر نهایی برطرف شود.

مثلا در زمانی که ترافیک بیش از حد انتظار در سیستم شما وجود دارد، نحوه طراحی پایگاه داده یا درست بودن معماری نرم افزار در رفع مشکل این مشکل اثرگذار است همه این تصمیمات باید با در نظر گرفتن مقیاس پذیری، قابلیت اطمینان، در دسترس بودن و قابلیت نگهداری به دقت گرفته شوند.

مثلا در اپلیکیشنی مثل اینستاگرام خیلی احمقانست است که فکر کنیم سیستم دیزاینی ساده ای مثل زیر داشته باشد
![](https://lh4.googleusercontent.com/94j-lwaV3KGyW4HutyAkWoa-rX-aBg8mgQhUWsEpbPzkcELaSFpTisStdN4KKMCTFh6IGsD0S8RHI5WjAPsXTH8woGOfWWyb66DqLxllYtlbvwFAYePNeJ29qn2NxKbnCB30WSr-Us14qTSOmQ)میتوانیم تصور کنیم که یک همچین سیستم دیزاینی برای اینستاگرام وجود دارد و سیستم دیزاین ساده ی بالا برای این اپلیکیشن وجود نداشته باشد. ([مرجع](https://www.youtube.com/watch?v=M8FZcBFQKsw&t=1122s))

![](https://lh6.googleusercontent.com/H00U4D8CbzFhKdu-rAyXSiYKVJPh-hiXD_O2K8YBdqBqSucom-w-gYxfgiZud3a-kt6jV8-No4RqTm16rfndeeA9if-x9Ov4rQm2tQoSig0k7h9gChwxI2PcnkX5a4OfmNqJPNpINqs50xfmog)

## معماری نرم افزار  (Software Architecture)

ما برای سیستم دیزاین محصولمون باید در طراحی نرم افزار دقت کنیم و اصولش را رعایت کنیم یا فرایند توسعه ی درستی انتخاب کنیم و خیلی موارد دیگر را به درستی پیش ببریم.

معماری های نرم افزار یکی دیگر از مواردی است که باید برای طراحی سیستم رعایت کنیم تا بتوانیم یک محصول یا نرم افزار خوبی را عرضه کنیم.

حالا تعریفش چی میشه ؟ یکی از بزرگان در مورد معماری نرم افزار تعریفی دارد که میفرماید :
In most successful software projects, the expert developers working on that project have a shared understanding of the system design. This shared understanding is called ‘architecture.’ 
در اکثر پروژه های نرم افزاری موفق، توسعه دهندگان متخصصی که روی آن پروژه کار می کنند، درک مشترکی از طراحی سیستم دارند. این درک مشترک "معماری" نامیده می شود
معماری نرم افزار دسته های کلی دارند و به چندین نوع تقسیم میشوند. میکروسرویس، معماری یکپارچه و ... از مدل های معماری نرم افزار هستند که در ادامه ی مقاله توضیح اجمالی در مورد معماری مونولیث و مفصل به سراغ میکروسرویس می رویم.

## معماری یکپارچه (Monolithic Architecture):
هر کسی که شروع به برنامه نویسی می کند این نوع معماری را استفاده می کنند. بدون اینکه اسمش رو بدونند از الگوهای رایج آن استفاده می کنند. در این معماری کلیه ی سورس های ی ما در یک ریپازیتوری و سورس قرار می گیرد. تمامی لایه ی لاجیک ، ارتباطِ ما با دیتابیس، کدهای بکند و فرانت ما یک جا قرار دارد و همه کسانی که تازه شروع به برنامه نویسی می کنند از این مدل معماری استفاده می کنند 
معماری مونولیث ۳ الگومعروف دارد که این ۳ الگو 
Single Monolithic - Layered Monolithic - Modular Monolithic
هستند. البته می تواند که الگو های دیگری هم وجود داشته باشند چون معماری ها انعطاف پذیر هستند و سفت و سخت نیستند و چارچوب خاصی ندارند.

این معماری فوائد خاص خودش را دارد هیچ وقت قدیمی نمی شوند و جاهای خودش کاربرد دارد پس اینکه این باور وجود دارد که این معماری قدیمی است درست نیست

چون ما نمی خواهیم درباره این معماری کامل صحبت کنیم مدل های آن را رایج توضیح نمی دهیم و بیشتر از این، مبحث را باز نمی کنیم.

## معماری میکروسرویس (Microservice Architecture):

در قسمت قبل معماری یکپارچه را بررسی کردیم ولی میکروسرویس ها اصلا به آن شکل نیستند.
سرویس های کوچک و گاهاً تک منظوره داریم که کنار هم کارهای بزرگی انجام میدهند.

![](https://lh5.googleusercontent.com/D2cjV2Z7L4qAvviI1_jcce1MY6wEN0IfKr-nFGOUxtz8dvKOueQbkiOhrDKHlDu1kO7t0hV9ZXuYr3F72v-KOZk15MppgzPMkELjFXtPLSRfyKohNV7fjwmLuSv9Kcc3ZASn0XXc-ee4L0gwYg)
آمازون، نتفلیکس، اوبر (Uber)، اتسی(Etsy) از شرکت های بزرگی هستند که از این معماری استفاده می کنند. در این [مقاله](https://medium.com/refraction-tech-everything/how-netflix-works-the-hugely-simplified-complex-stuff-that-happens-every-time-you-hit-play-3a40c9be254b) از سایت Medium میتوانید عملکرد نتفلیکس را در میکروسرویس ببینید.

برای درک بهتر این معماری به ۳ مثالی که از اینستاگرام و اوبر و سبد خرید زدیم توجه کنید و بعد در این بحث عمیق تر شویم.

اول مقاله درباره ی System Design ای اینستاگرام دارد توضیحی دادیم. کل ریکوئست های کاربر که از نوع Write است در یک ریپازیتوری وجود ندارد. آنها را ریز کرده و به سرویس های کوچکی تقسیم کرده است. مثلا Story - Post - Notification - Reels هر کدام سرویس جداگانه ای هستند، دیتابیس جداگانه ای دارند و جدا از هم نوشته می شوند

![](https://lh5.googleusercontent.com/n5F-ySoMPaesDC5qxwZKnfIih0fqx6yxyI5l-vGNiKxRqKMx0mObZ7seWo38yFBHkUaRQfm19OQvZz_l2_GfTPi-lw4idxfqHFEdTBrqit6_JBoJ44-3NnmrFMl0o3Rh8RtLM5qE3baOwHpoOg)
هر سرویس فعالیت خاصی به عهده دارد مثلا میکروسرویس story برای استوری گذاشتن های یک کاربر و قوانین مربوط به آن است. سرویس post هم به همین ترتیب یا مثلا سرویس Notification به این صورت است که اگر نوتیفیکیشن یک کاربری روشن باشد پیغام استوری گذاشتن پست گذاشتن و نوتیفیکیشن ارسال شدن پیام و… را به عهده دارد. هر سرویس همینطور یک وظیفه ی کوچک و کاری کوچک را دارد.

یا در معماری پایین که می بینیم مثل اپلیکیشن مثل Uber که در ایران اسنپ یا تپسی رو مثل آن را داریم است. ما اینجا می خواهیم یک سری راننده به یک سری مسافر به هم وصل شوند و سفرهایی برای مسافران طی شود و در آخر کرایه ای توسط مسافر به راننده پرداخت شود.

![](https://lh5.googleusercontent.com/wTej89RPtYFMQoTIVKr7XX2VS2DDNVKMBEvUSE-WzPKw2q7bbx-XRHPK-FvppX6xwDTGfoNHV3nyakIwL7X4xhsuSR-72xxoZwShIboerEa-oRaaJC_VDI14KRJdZ4cD-2EoK8QXvCcSXE1eCw)در سرویس Driver 
تمامی کارهای مربوط به راننده از جمله ثبت نام راننده، موقعیت جغرافیایی آن در نقشه، آنلاین بودن یا آفلاین بودن راننده، آیا راننده دنبال مسافر هست یا خیر و…. در این سرویس انجام می شود.

در سرویس Passenger
 مسافرین ما هستند تمامی کارهای مربوط به مسافر من جمله Status آنها یا انتخاب مبدا مقصد یا درخواست پیدا شدن راننده برای یک سفر و… در این سرویس است.

در سرویس Trip
 مشخص میشود که مسافر و راننده در چه وضعیتی هستند مثل کد پیگیری سفر یا چه راننده ای سفیر است یا چه مسافری سفر رو طی میکند و چه زمانی در سفر است و…

  

در سرویس ‌Biling پردازش مالی و هزینه را به عهده دارد مثلا آنلاین هزینه پرداخت می شود یا به صورت نقدی
 یا اینکه هزینه ی یک سفر چقدر است و…

در سرویس Notification
 کاری که انجام می دهد اینطور است که مثلا به مسافر پیام دهد که سفیری پیدا شد یا اینکه به راننده پیام دهد که مسافری درخواست سفر در فاصله ی x کیلومتری را داده است یا پیام دهد به راننده که مسافر هزینه را به صورت آنلاین پرداخت کرده است و…

  
این سرویس ها در این ۲ مثال از لحاظ Logic کار کوچکی انجام می دهند. اگر با معماری Monolithic می خواستیم این پروژه ها را بزنیم همه ی این ها داخل یک Source قرار داشتند.

ولی در اینجا هر کدام از سرویس ها :
-   یک سورس کد جداگانه ای داشته باشند.
-   دیتابیس جداگانه داشته باشند.
-   یک تیم پشتیبانی و توسعه خودش را داشته باشد.
   
و خیلی مزیت دیگر که در بررسی یک میکروسرویس خوب بهش اشاره خواهیم کرد.

یا در معماری سبد خرید :

وقتی برنامه سبد خرید رو باز میکنید، تمام چیزی که میبینیم یک وب سایت است. اما در پس زمینه سرویس هایی مثل پرداخت، مدیریت کاربران، مدیریت محصولات و... وجود داره.

حالا بیاید فرض کنیم که این برنامه با یک فریم ورک یکپارچه طراحی شده است که شکلش رو پایین میتونید ببینید

![](https://lh4.googleusercontent.com/_b9MUiFqPM0Y7aksww7A9occKPxjjOAa7lsNAdTU9gVtJPKiwk7dxHsJdam1h9u-LfNBApZG3Kt9Xq9tFprqdYeLEimac5zFcH1e37Ch0MF_zfqSbpCZE3u_UpfoT3RMPAouiVFv1sr-qWufFw)
با توجه که چیزی که توی شکل میبینیم متوجه میشویم که همه قسمت های برنامه کنار هم قرار گرفتن و از یه دیتابیس واحد دارن استفاده میکنن.

حالا فکر کنید که یک قسمت جدید باید به برنامه اضافه شود و دولوپر های این برنامه ناچار می شوند قسمت مربوطه رو با تمام وابستگی ها و تغییرات لازمه اش به برنامه اضافه کنند. حالا نه تنها باید روی قسمت های موجود توی سیستم دوباره کاری کنند بلکه مجبور می شوند حتی کل سیستم رو کاملا تغییر بدهند و دوباره مستقر کنند و دردسرهای خودش را دارد. به همین خاطر حالا توسعه دهنده ها تصمیم می گیرند برن سراغ میکروسرویس تا بتوانند نیازهای بعدی رو هم به راحتی پوشش بدهند. شکل زیر معماری جدید آنها می شود.

![](https://lh5.googleusercontent.com/uwf8LackEl_dkBeGry0PpTw0VmN6RptGlGo5RSdqn0X1HlMy_sGu8PrnQmYVoB-UVwZ6-R9gkjacH1BAMwIjCjHYqz2tw_N-Pzh9BNKDPQzY0AuuraEcjbXlM2PJRjW-o78TYqzG5-R9ZunRWg)
استقرار مستقل (Independent Deployment) :

بر اساس سرویسی که ارائه میدهند، میتوانند در هر برنامه ای مستقر شوند یعنی هر سرویس باید به صورت جدا از سرویس دیگری باید توسعه پیدا کنند یا دیپلوی شوند یا باگ فیکس شوند و ربطی به سرویس دیگری نداشته باشند یا با تغییر و بهینه کردن آنها نباید مشکلی در سرویس دیگر به وجود آید. به طور مثال در اینستاگرام اگر در سرویس Feed تغییراتی دادیم نباید در سرویس Post یا Story تغییری به عمل آید و اختلالی در کار آن به وجود بیاید.

یا در سرویس پرداخت الکترونیکی اگر تغییری به وجود آید نباید سرویس سبد خرید تغییر پیدا کند. تیم سرویس A نباید به تیم سرویس B گوید که من سرویسم را تغییر دادم پس شما هم باید تغییری در سرویس خود بدی تا اشکالش برطرف شود و درست کار کند.

  
  
  

Business Domain :

  

هر سرویس ممکن است دامین خودش را داشته باشد. مثلا سرویس پرداخت (Billing) دامین رو خودش را داشته باشد یا سرویس Driver,Passenger دامین خودشان را دارند. این بحث بیشتر به مبحث DDD برمیگردد و بنده اطلاعات زیادی ندارم و یک [لینکی](https://circleci.com/blog/exploring-domain-driven-design-at-circleci/?utm_source=google&utm_medium=sem&utm_campaign=sem-google-dg--uscan-en-dsa-maxConv-auth-brand&utm_term=g_-_c__dsa_&utm_content=&gclid=CjwKCAjw7cGUBhA9EiwArBAvolgk-dxOq9ddzFRzUhyAGx0ZNAylSAAy9t4kJ6Co14iOjjGqgTZXHBoC0T0QAvD_BwE) جهت مطالعه میگذارم

  

Own State :

هر سرویس باید مالک (Owner) خودشون باشند. یعنی هر کدام باید به حالت ها، شرایطی که آن سرویس نیاز دارد (State) درست باشد که این سرویس به وظیفه ی خودشان عمل کنند. تغییر در کد هرکدام نباید به دیگری آسیبی برساند.

مثلا هر سرویس دیتابیس خودش را دارد و یک دیتابیس به عنوان دیتابیس اصلی که همه ی سرویس ها در آن اطلاعات واکشی یا ذخیره میکنند وجود ندارد. مثلا در سرویس استوری در اینستا می توانیم ببینیم هر کس چه استوری ای در چند ساعت قبل گذاشته است یا مثلا در پروفایلمان می توانیم هیستوری استوری های خود را ببینیم و…

  

Low Coupling High Cohesion (اتصال کم و انسجام بالا):

  

ویژگی اصلی یک کد قابل نگهداری، پایبندی به "اتصال کم، انسجام بالا" است. حالا معنیش یعنی چی ؟‌

در شی گرایی این مبحث را توضیح دهیم اینطور است که کلاس ها باید تا حد امکان مستقل از سایر کلاس ها باشند، به طوری که تغییرات در کلاس ها تاثیر زیادی بر دیگر کلاس ها نداشته باشد.

در میکروسرویس هم همین موضوع برقراره و باید حواسمان باشد که :

باید هر میکروسرویس نباید یک کار رو چند جای مختلف نوشته شده باشد (اصل DRY در اصول طراحی نرم افزار و کدنویسی) (Low Coupling)

و هر نیازی که یک سرویس دارد در همان سرویس نوشته شود مثلا نیازمندی های سرویس Driver باید در همان سرویس نوشته شود.(High cohesion)

  

سایز میکروسرویس ها موضوع بعدی است.

  

به صورت دقیق نمی شود عنوان کرد که اگر یک میکروسرویس ها از چقدر بزرگتر و یا چقدر کمتر باشد میکروسرویس بزرگ یا کوچک هستند.

مثلا تعداد خط یک کد معیار بود که اصلا معیار خوبی نیست چون زبانهای مختلف خط های که مختلفی در مورد یک الگوریتم دارند.

اساتید نرم افزار می فرمایند که در حدی باید بزرگ باشند که در ذهن ما جا شوند ولی باز هم درباره ی سایز به صورت دقیق نمی شود صحبت کرد و به فرهنگ آن سازمان و شرکت و تولید محصول آن ربط دارد.

  

بحث Scalable بودن معیار بعدی است. آیا سرویسمان مقیاس پذیر است یا خیر ؟

اصولی تحت [اصول ۱۲ گانه کلاد نیتیو](https://12factor.net) را با رعایت شود تا بتوانیم سرویسمان Scalable باشند.

موارد دیگر و معیار های دیگر وجود دارد که رعایت کردن آنها باعث ایجاد یک میکروسرویس خوب می شود. من مواردی ک شنیده بودم و یا بهتر بلد بودم را در اینجا آورده ام و قاعدتا شما با سرچ می توانید موارد دیگر را هم متوجه شوید و به بنده هم آموزش دهید.

  

مرسی از توجه شما که تا اینجا دنبال کردید

